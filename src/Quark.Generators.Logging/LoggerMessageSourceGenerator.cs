using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Quark.Generators.Logging;

/// <summary>
///     Source generator for high-performance logging using LoggerMessage pattern.
///     Generates compile-time logging methods with zero allocation.
/// </summary>
[Generator]
public class LoggerMessageSourceGenerator : IIncrementalGenerator
{
    private const string AttributeSource = @"// <auto-generated/>
namespace Quark.Abstractions;

/// <summary>
/// Marks a partial method for high-performance logger message generation.
/// The method must be partial and include an ILogger parameter.
/// </summary>
[System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple = false)]
public sealed class QuarkLoggerMessageAttribute : System.Attribute
{
    /// <summary>
    /// Initializes a new instance of the QuarkLoggerMessageAttribute.
    /// </summary>
    /// <param name=""level"">The log level (e.g., ""Information"", ""Warning"", ""Error"").</param>
    /// <param name=""message"">The log message template with placeholders.</param>
    public QuarkLoggerMessageAttribute(string level, string message)
    {
        Level = level;
        Message = message;
    }

    /// <summary>
    /// Gets the log level.
    /// </summary>
    public string Level { get; }

    /// <summary>
    /// Gets the log message template.
    /// </summary>
    public string Message { get; }
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the attribute first
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("QuarkLoggerMessageAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Find all methods with [QuarkLoggerMessage] attribute
        var methodsWithAttribute = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsCandidateMethod(s),
                static (ctx, _) => GetSemanticTarget(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(methodsWithAttribute, static (spc, method) =>
        {
            if (method is null) return;
            GenerateLoggerMethod(spc, method.Value);
        });
    }

    private static bool IsCandidateMethod(SyntaxNode node)
    {
        return node is MethodDeclarationSyntax method &&
               method.AttributeLists.Count > 0 &&
               method.Modifiers.Any(SyntaxKind.PartialKeyword);
    }

    private static (IMethodSymbol Method, AttributeData Attribute)? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var methodDeclaration = (MethodDeclarationSyntax)context.Node;
        var methodSymbol = context.SemanticModel.GetDeclaredSymbol(methodDeclaration);

        if (methodSymbol is null) return null;

        var attribute = methodSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "QuarkLoggerMessageAttribute");

        return attribute is null ? null : (methodSymbol, attribute);
    }

    private static void GenerateLoggerMethod(SourceProductionContext context,
        (IMethodSymbol Method, AttributeData Attribute) data)
    {
        var (method, attribute) = data;
        var containingType = method.ContainingType;

        // Extract attribute parameters
        var level = attribute.ConstructorArguments[0].Value?.ToString() ?? "Information";
        var message = attribute.ConstructorArguments[1].Value?.ToString() ?? "";

        // Get parameters
        var parameters = method.Parameters
            .Where(p => p.Type.Name != "ILogger")
            .Select(p => $"{p.Type.ToDisplayString()} {p.Name}")
            .ToList();

        var parameterNames = method.Parameters
            .Where(p => p.Type.Name != "ILogger")
            .Select(p => p.Name)
            .ToList();

        var source = GenerateLoggerMethodSource(
            containingType.ContainingNamespace.ToDisplayString(),
            containingType.Name,
            method.Name,
            level,
            message,
            parameters,
            parameterNames);

        context.AddSource($"{containingType.Name}.{method.Name}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateLoggerMethodSource(
        string namespaceName,
        string className,
        string methodName,
        string level,
        string message,
        List<string> parameters,
        List<string> parameterNames)
    {
        var parametersString = string.Join(", ", parameters);
        var parameterNamesString = parameterNames.Count > 0 ? ", " + string.Join(", ", parameterNames) : "";

        return $@"// <auto-generated/>
#nullable enable

using Microsoft.Extensions.Logging;

namespace {namespaceName};

partial class {className}
{{
    private static readonly System.Action<ILogger, {string.Join(", ", parameterNames.Select(p => "object?"))}, System.Exception?> __{methodName}Callback =
        LoggerMessage.Define{(parameterNames.Count > 0 ? $"<{string.Join(", ", parameterNames.Select(p => "object?"))}>" : "")}(
            LogLevel.{level},
            new EventId({methodName.GetHashCode()}, ""{methodName}""),
            ""{message}"");

    partial void {methodName}(ILogger logger{(parameters.Count > 0 ? ", " + parametersString : "")})
    {{
        __{methodName}Callback(logger{parameterNamesString}, null);
    }}
}}
";
    }
}