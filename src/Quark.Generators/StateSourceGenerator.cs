using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Quark.Generators;

/// <summary>
///     Source generator for QuarkState attribute.
///     Generates partial properties and Save/Load methods for state management.
/// </summary>
[Generator]
public class StateSourceGenerator : IIncrementalGenerator
{
    private const string QuarkStateAttributeSource = """
                                                     // <auto-generated/>
                                                     #nullable enable

                                                     namespace Quark.Abstractions.Persistence
                                                     {
                                                         /// <summary>
                                                         /// Marks a property as a persisted state that should be code-generated.
                                                         /// </summary>
                                                         [System.AttributeUsage(System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
                                                         public sealed class QuarkStateAttribute : System.Attribute
                                                         {
                                                             /// <summary>
                                                             /// Initializes a new instance of the <see cref="QuarkStateAttribute"/> class.
                                                             /// </summary>
                                                             /// <param name="providerName">The name of the storage provider (e.g., "sql-db", "redis-cache").</param>
                                                             public QuarkStateAttribute(string providerName)
                                                             {
                                                                 ProviderName = providerName;
                                                             }

                                                             /// <summary>
                                                             /// Gets the name of the storage provider.
                                                             /// </summary>
                                                             public string ProviderName { get; }

                                                             /// <summary>
                                                             /// Gets or sets the name to use for storing this state.
                                                             /// If not specified, the property name is used.
                                                             /// </summary>
                                                             public string? Name { get; set; }
                                                         }
                                                     }
                                                     """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the QuarkState attribute source
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "QuarkStateAttribute.g.cs",
            SourceText.From(QuarkStateAttributeSource, Encoding.UTF8)));

        // Find all properties with the QuarkState attribute
        var stateProperties = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m.HasValue);

        // Generate code for each state property
        context.RegisterSourceOutput(stateProperties,
            static (spc, source) => Execute(source!.Value, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is PropertyDeclarationSyntax propertyDeclaration
               && propertyDeclaration.AttributeLists.Count > 0;
    }

    private static (PropertyDeclarationSyntax Property, ClassDeclarationSyntax Class, SemanticModel Model)?
        GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var propertyDeclaration = (PropertyDeclarationSyntax)context.Node;
        var classDeclaration = propertyDeclaration.Ancestors()
            .OfType<ClassDeclarationSyntax>()
            .FirstOrDefault();

        if (classDeclaration == null)
            return null;

        foreach (var attributeList in propertyDeclaration.AttributeLists)
        foreach (var attribute in attributeList.Attributes)
        {
            var symbolInfo = context.SemanticModel.GetSymbolInfo(attribute);
            if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeType = attributeSymbol.ContainingType;
            var fullName = attributeType.ToDisplayString();

            if (fullName == "Quark.Abstractions.Persistence.QuarkStateAttribute")
                return (propertyDeclaration, classDeclaration, context.SemanticModel);
        }

        return null;
    }

    private static void Execute(
        (PropertyDeclarationSyntax Property, ClassDeclarationSyntax Class, SemanticModel Model) input,
        SourceProductionContext context)
    {
        var (propertyDeclaration, classDeclaration, semanticModel) = input;

        var className = classDeclaration.Identifier.Text;
        var propertyName = propertyDeclaration.Identifier.Text;
        var propertyType = propertyDeclaration.Type.ToString();
        var namespaceName = GetNamespace(classDeclaration);

        // Extract attribute parameters
        var attribute = propertyDeclaration.AttributeLists
            .SelectMany(al => al.Attributes)
            .FirstOrDefault(a => a.Name.ToString().Contains("QuarkState"));

        if (attribute == null)
            return;

        // Get provider name from attribute
        var providerName = "default";
        string? stateName = null;

        if (attribute.ArgumentList != null)
        {
            var args = attribute.ArgumentList.Arguments;
            if (args.Count > 0) providerName = args[0].Expression.ToString().Trim('"');

            // Look for named parameter 'name'
            foreach (var arg in args)
                if (arg.NameColon != null && arg.NameColon.Name.Identifier.Text == "name")
                    stateName = arg.Expression.ToString().Trim('"');
        }

        stateName ??= propertyName;

        // Generate JsonSerializerContext for AOT-safe serialization
        var jsonContextSource = $$"""
                                  // <auto-generated/>
                                  #nullable enable
                                  using System.Text.Json.Serialization;

                                  namespace {{namespaceName}}
                                  {
                                      /// <summary>
                                      /// JSON serialization context for {{propertyType}} - enables AOT compilation with zero reflection.
                                      /// </summary>
                                      [JsonSerializable(typeof({{propertyType}}))]
                                      [JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]
                                      internal partial class {{propertyName}}JsonContext : JsonSerializerContext
                                      {
                                      }
                                  }
                                  """;
        
        context.AddSource($"{className}.{propertyName}JsonContext.g.cs", SourceText.From(jsonContextSource, Encoding.UTF8));

        // Generate the helper methods for loading and saving state with versioning support
        var source = $$"""
                       // <auto-generated/>
                       #nullable enable
                       using Quark.Abstractions.Persistence;

                       namespace {{namespaceName}}
                       {
                           partial class {{className}}
                           {
                               private long? _{{propertyName}}Version;

                               /// <summary>
                               /// Loads the {{propertyName}} state from storage with version tracking for optimistic concurrency.
                               /// </summary>
                               public async Task Load{{propertyName}}Async(CancellationToken cancellationToken = default)
                               {
                                   var storage = GetStorage<{{propertyType}}>("{{providerName}}");
                                   var result = await storage.LoadWithVersionAsync(ActorId, "{{stateName}}", cancellationToken);
                                   if (result != null)
                                   {
                                       {{propertyName}} = result.State;
                                       _{{propertyName}}Version = result.Version;
                                   }
                                   else
                                   {
                                       {{propertyName}} = new {{propertyType}}();
                                       _{{propertyName}}Version = null; // First save will create version 1
                                   }
                               }

                               /// <summary>
                               /// Saves the {{propertyName}} state to storage with optimistic concurrency control.
                               /// Throws ConcurrencyException if the state was modified by another operation.
                               /// </summary>
                               public async Task Save{{propertyName}}Async(CancellationToken cancellationToken = default)
                               {
                                   if ({{propertyName}} == null)
                                   {
                                       throw new InvalidOperationException($"Cannot save null state '{{propertyName}}'.");
                                   }
                                   
                                   var storage = GetStorage<{{propertyType}}>("{{providerName}}");
                                   _{{propertyName}}Version = await storage.SaveWithVersionAsync(
                                       ActorId, 
                                       "{{stateName}}", 
                                       {{propertyName}}, 
                                       _{{propertyName}}Version, 
                                       cancellationToken);
                               }

                               /// <summary>
                               /// Deletes the {{propertyName}} state from storage.
                               /// </summary>
                               public async Task Delete{{propertyName}}Async(CancellationToken cancellationToken = default)
                               {
                                   var storage = GetStorage<{{propertyType}}>("{{providerName}}");
                                   await storage.DeleteAsync(ActorId, "{{stateName}}", cancellationToken);
                                   {{propertyName}} = null;
                                   _{{propertyName}}Version = null;
                               }
                           }
                       }
                       """;

        context.AddSource($"{className}.{propertyName}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        var namespaceDeclaration = classDeclaration.Ancestors()
            .OfType<NamespaceDeclarationSyntax>()
            .FirstOrDefault();

        if (namespaceDeclaration != null)
            return namespaceDeclaration.Name.ToString();

        var fileScopedNamespace = classDeclaration.Ancestors()
            .OfType<FileScopedNamespaceDeclarationSyntax>()
            .FirstOrDefault();

        return fileScopedNamespace?.Name.ToString() ?? "Global";
    }
}