using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Quark.Generators;

/// <summary>
/// Source generator for QuarkState attribute.
/// Generates partial properties and Save/Load methods for state management.
/// </summary>
[Generator]
public class StateSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the QuarkState attribute source
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "QuarkStateAttribute.g.cs",
            SourceText.From(QuarkStateAttributeSource, Encoding.UTF8)));

        // Find all properties with the QuarkState attribute
        var stateProperties = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m.HasValue);

        // Generate code for each state property
        context.RegisterSourceOutput(stateProperties,
            static (spc, source) => Execute(source!.Value, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is PropertyDeclarationSyntax propertyDeclaration
            && propertyDeclaration.AttributeLists.Count > 0;
    }

    private static (PropertyDeclarationSyntax Property, ClassDeclarationSyntax Class, SemanticModel Model)? 
        GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var propertyDeclaration = (PropertyDeclarationSyntax)context.Node;
        var classDeclaration = propertyDeclaration.Ancestors()
            .OfType<ClassDeclarationSyntax>()
            .FirstOrDefault();

        if (classDeclaration == null)
            return null;

        foreach (var attributeList in propertyDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var symbolInfo = context.SemanticModel.GetSymbolInfo(attribute);
                if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                    continue;

                var attributeType = attributeSymbol.ContainingType;
                var fullName = attributeType.ToDisplayString();

                if (fullName == "Quark.Abstractions.Persistence.QuarkStateAttribute")
                {
                    return (propertyDeclaration, classDeclaration, context.SemanticModel);
                }
            }
        }

        return null;
    }

    private static void Execute(
        (PropertyDeclarationSyntax Property, ClassDeclarationSyntax Class, SemanticModel Model) input,
        SourceProductionContext context)
    {
        var (propertyDeclaration, classDeclaration, semanticModel) = input;

        var className = classDeclaration.Identifier.Text;
        var propertyName = propertyDeclaration.Identifier.Text;
        var propertyType = propertyDeclaration.Type.ToString();
        var namespaceName = GetNamespace(classDeclaration);

        // Extract attribute parameters
        var attribute = propertyDeclaration.AttributeLists
            .SelectMany(al => al.Attributes)
            .FirstOrDefault(a => a.Name.ToString().Contains("QuarkState"));

        if (attribute == null)
            return;

        // Get provider name from attribute
        string providerName = "default";
        string? stateName = null;

        if (attribute.ArgumentList != null)
        {
            var args = attribute.ArgumentList.Arguments;
            if (args.Count > 0)
            {
                providerName = args[0].Expression.ToString().Trim('"');
            }

            // Look for named parameter 'name'
            foreach (var arg in args)
            {
                if (arg.NameColon != null && arg.NameColon.Name.Identifier.Text == "name")
                {
                    stateName = arg.Expression.ToString().Trim('"');
                }
            }
        }

        stateName ??= propertyName;

        // Generate the helper methods for loading and saving state
        var source = $$"""
            // <auto-generated/>
            #nullable enable
            using Quark.Abstractions.Persistence;

            namespace {{namespaceName}}
            {
                partial class {{className}}
                {
                    /// <summary>
                    /// Loads the {{propertyName}} state from storage.
                    /// </summary>
                    public async Task Load{{propertyName}}Async(CancellationToken cancellationToken = default)
                    {
                        var storage = GetStorage<{{propertyType}}>("{{providerName}}");
                        {{propertyName}} = await storage.LoadAsync(ActorId, "{{stateName}}", cancellationToken);
                        if ({{propertyName}} == null)
                        {
                            {{propertyName}} = new {{propertyType}}();
                        }
                    }

                    /// <summary>
                    /// Saves the {{propertyName}} state to storage.
                    /// </summary>
                    public async Task Save{{propertyName}}Async(CancellationToken cancellationToken = default)
                    {
                        if ({{propertyName}} == null)
                        {
                            throw new InvalidOperationException($"Cannot save null state '{{propertyName}}'.");
                        }
                        
                        var storage = GetStorage<{{propertyType}}>("{{providerName}}");
                        await storage.SaveAsync(ActorId, "{{stateName}}", {{propertyName}}, cancellationToken);
                    }

                    /// <summary>
                    /// Deletes the {{propertyName}} state from storage.
                    /// </summary>
                    public async Task Delete{{propertyName}}Async(CancellationToken cancellationToken = default)
                    {
                        var storage = GetStorage<{{propertyType}}>("{{providerName}}");
                        await storage.DeleteAsync(ActorId, "{{stateName}}", cancellationToken);
                        {{propertyName}} = null;
                    }
                }
            }
            """;

        context.AddSource($"{className}.{propertyName}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        var namespaceDeclaration = classDeclaration.Ancestors()
            .OfType<NamespaceDeclarationSyntax>()
            .FirstOrDefault();

        if (namespaceDeclaration != null)
            return namespaceDeclaration.Name.ToString();

        var fileScopedNamespace = classDeclaration.Ancestors()
            .OfType<FileScopedNamespaceDeclarationSyntax>()
            .FirstOrDefault();

        return fileScopedNamespace?.Name.ToString() ?? "Global";
    }

    private const string QuarkStateAttributeSource = """
        // <auto-generated/>
        #nullable enable

        namespace Quark.Abstractions.Persistence
        {
            /// <summary>
            /// Marks a property as a persisted state that should be code-generated.
            /// </summary>
            [System.AttributeUsage(System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
            public sealed class QuarkStateAttribute : System.Attribute
            {
                /// <summary>
                /// Initializes a new instance of the <see cref="QuarkStateAttribute"/> class.
                /// </summary>
                /// <param name="providerName">The name of the storage provider (e.g., "sql-db", "redis-cache").</param>
                public QuarkStateAttribute(string providerName)
                {
                    ProviderName = providerName;
                }

                /// <summary>
                /// Gets the name of the storage provider.
                /// </summary>
                public string ProviderName { get; }

                /// <summary>
                /// Gets or sets the name to use for storing this state.
                /// If not specified, the property name is used.
                /// </summary>
                public string? Name { get; set; }
            }
        }
        """;
}
