using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Quark.Generators;

/// <summary>
///     Source generator for creating Protocol Buffer definitions and type-safe client proxies from actor interfaces.
///     Part of Phase 9.1: Enhanced Source Generators - Protobuf Proxy Generation.
/// </summary>
[Generator]
public class ProtoSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with the Actor attribute
        var actorClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Collect all actor classes
        var compilation = context.CompilationProvider.Combine(actorClasses.Collect());

        // Generate proto files and proxies for all actors
        context.RegisterSourceOutput(compilation,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration
               && classDeclaration.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDeclaration.AttributeLists)
        foreach (var attribute in attributeList.Attributes)
        {
            var symbolInfo = context.SemanticModel.GetSymbolInfo(attribute);
            if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeType = attributeSymbol.ContainingType;
            var fullName = attributeType.ToDisplayString();

            if (fullName == "Quark.Abstractions.ActorAttribute") return classDeclaration;
        }

        return null;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax?> actorClasses,
        SourceProductionContext context)
    {
        if (actorClasses.IsEmpty)
            return;

        var protoFileBuilder = new StringBuilder();
        protoFileBuilder.AppendLine("syntax = \"proto3\";");
        protoFileBuilder.AppendLine();
        protoFileBuilder.AppendLine("option csharp_namespace = \"Quark.Generated.Protos\";");
        protoFileBuilder.AppendLine();
        protoFileBuilder.AppendLine("package quark.actors;");
        protoFileBuilder.AppendLine();
        protoFileBuilder.AppendLine("// Generated actor service definitions");
        protoFileBuilder.AppendLine("// Version: 1.0.0");
        protoFileBuilder.AppendLine();

        var messageTypes = new HashSet<string>();
        var messageNumber = 1;

        foreach (var classDeclaration in actorClasses)
        {
            if (classDeclaration is null)
                continue;

            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

            if (classSymbol is null)
                continue;

            // Generate proto service definition for this actor
            GenerateProtoService(classSymbol, protoFileBuilder, messageTypes, ref messageNumber, context);

            // Generate C# client proxy for this actor
            GenerateClientProxy(classSymbol, context, compilation);
        }

        // Add common message types at the end
        GenerateCommonMessages(protoFileBuilder, messageTypes);

        // Output the combined proto file as a comment documentation file
        // Note: .proto files are not compiled as C# source, so we output as a text file for reference
        var protoDoc = $$"""
// <auto-generated/>
// This file contains the Protocol Buffer definitions for actor services.
// It is generated for documentation purposes and is not compiled.
// 
// To use these definitions with gRPC tooling, extract the content below
// and save it as ActorServices.proto
//
/*
{{protoFileBuilder}}
*/
""";
        context.AddSource("ActorServices.proto.txt.g.cs", SourceText.From(protoDoc, Encoding.UTF8));
    }

    private static void GenerateProtoService(
        INamedTypeSymbol classSymbol,
        StringBuilder protoBuilder,
        HashSet<string> messageTypes,
        ref int messageNumber,
        SourceProductionContext context)
    {
        var className = classSymbol.Name;
        var serviceName = className.Replace("Actor", "");

        protoBuilder.AppendLine($"// Service for {className}");
        protoBuilder.AppendLine($"service {serviceName}Service {{");

        // Get all public methods
        var methods = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Public
                        && !m.IsStatic
                        && m.MethodKind == MethodKind.Ordinary
                        && m.Name != "OnActivateAsync"
                        && m.Name != "OnDeactivateAsync"
                        && !m.Name.StartsWith("get_")
                        && !m.Name.StartsWith("set_"))
            .ToList();

        foreach (var method in methods)
        {
            var methodName = method.Name.Replace("Async", "");
            var requestType = $"{serviceName}{methodName}Request";
            var responseType = $"{serviceName}{methodName}Response";

            protoBuilder.AppendLine($"  rpc {methodName} ({requestType}) returns ({responseType});");

            // Track message types for later generation
            messageTypes.Add($"{requestType}:{method}");
            messageTypes.Add($"{responseType}:{method}");
        }

        protoBuilder.AppendLine("}");
        protoBuilder.AppendLine();
    }

    private static void GenerateCommonMessages(StringBuilder protoBuilder, HashSet<string> messageTypes)
    {
        protoBuilder.AppendLine("// Message definitions");
        protoBuilder.AppendLine();

        foreach (var messageType in messageTypes)
        {
            var parts = messageType.Split(':');
            var typeName = parts[0];
            // For now, generate simple message wrappers
            // In a full implementation, we would analyze the actual method signatures

            if (typeName.EndsWith("Request"))
            {
                protoBuilder.AppendLine($"message {typeName} {{");
                protoBuilder.AppendLine("  string actor_id = 1;");
                protoBuilder.AppendLine("  bytes payload = 2;  // Serialized parameters");
                protoBuilder.AppendLine("}");
                protoBuilder.AppendLine();
            }
            else if (typeName.EndsWith("Response"))
            {
                protoBuilder.AppendLine($"message {typeName} {{");
                protoBuilder.AppendLine("  bytes payload = 1;  // Serialized result");
                protoBuilder.AppendLine("  bool success = 2;");
                protoBuilder.AppendLine("  string error_message = 3;");
                protoBuilder.AppendLine("}");
                protoBuilder.AppendLine();
            }
        }
    }

    private static void GenerateClientProxy(
        INamedTypeSymbol classSymbol,
        SourceProductionContext context,
        Compilation compilation)
    {
        // Check if IClusterClient and QuarkEnvelope types are available
        var clusterClientType = compilation.GetTypeByMetadataName("Quark.Client.IClusterClient");
        var envelopeType = compilation.GetTypeByMetadataName("Quark.Networking.Abstractions.QuarkEnvelope");

        if (clusterClientType == null || envelopeType == null)
        {
            // Types not available - skip proxy generation
            // This is expected for projects that don't reference Quark.Client
            return;
        }

        var className = classSymbol.Name;
        var proxyName = $"{className}Proxy";
        var interfaceName = $"I{className}Proxy";
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

        // Get all public methods
        var methods = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Public
                        && !m.IsStatic
                        && m.MethodKind == MethodKind.Ordinary
                        && m.Name != "OnActivateAsync"
                        && m.Name != "OnDeactivateAsync"
                        && !m.Name.StartsWith("get_")
                        && !m.Name.StartsWith("set_"))
            .ToList();

        if (methods.Count == 0)
            return; // No methods to proxy

        var interfaceBuilder = new StringBuilder();
        var proxyBuilder = new StringBuilder();

        // Build interface
        foreach (var method in methods)
        {
            var returnType = GetReturnTypeString(method);
            var parameters = string.Join(", ", method.Parameters.Select(p => 
                $"{p.Type.ToDisplayString()} {p.Name}"));
            
            interfaceBuilder.AppendLine($"    {returnType} {method.Name}({parameters});");
        }

        // Build proxy implementation
        foreach (var method in methods)
        {
            var returnType = GetReturnTypeString(method);
            var parameters = string.Join(", ", method.Parameters.Select(p => 
                $"{p.Type.ToDisplayString()} {p.Name}"));
            var paramArray = method.Parameters.Length > 0 
                ? string.Join(", ", method.Parameters.Select(p => p.Name))
                : "";

            // Determine the actual result type (unwrap Task<T>)
            var resultType = GetTaskResultType(method);
            var hasResult = resultType != null;

            proxyBuilder.AppendLine($"    public async {returnType} {method.Name}({parameters})");
            proxyBuilder.AppendLine("    {");
            
            if (IsAsyncMethod(method))
            {
                if (method.Parameters.Length > 0)
                {
                    proxyBuilder.AppendLine($"        var envelope = CreateEnvelope(\"{method.Name}\", new object[] {{ {paramArray} }});");
                }
                else
                {
                    proxyBuilder.AppendLine($"        var envelope = CreateEnvelope(\"{method.Name}\", Array.Empty<object>());");
                }
                proxyBuilder.AppendLine("        var response = await _client.SendAsync(envelope);");
                
                if (hasResult)
                {
                    proxyBuilder.AppendLine($"        return DeserializeResponse<{resultType}>(response);");
                }
                else
                {
                    proxyBuilder.AppendLine("        // Task without result - just check for errors");
                    proxyBuilder.AppendLine("        if (response.IsError)");
                    proxyBuilder.AppendLine("        {");
                    proxyBuilder.AppendLine("            throw new InvalidOperationException($\"Actor method failed: {response.ErrorMessage}\");");
                    proxyBuilder.AppendLine("        }");
                }
            }
            else
            {
                proxyBuilder.AppendLine($"        throw new NotSupportedException(\"Synchronous methods are not supported in proxies. Use async methods.\");");
            }
            
            proxyBuilder.AppendLine("    }");
            proxyBuilder.AppendLine();
        }

        var source = $$"""
// <auto-generated/>
#nullable enable
using System;
using System.Threading;
using System.Threading.Tasks;
using Quark.Client;
using Quark.Networking.Abstractions;

namespace {{namespaceName}}.Generated
{
    /// <summary>
    /// Client proxy interface for {{className}}.
    /// Provides type-safe remote method invocation.
    /// </summary>
    public interface {{interfaceName}}
    {
{{interfaceBuilder}}
    }

    /// <summary>
    /// Client proxy implementation for {{className}}.
    /// Generated by ProtoSourceGenerator for type-safe actor invocation.
    /// </summary>
    public class {{proxyName}} : {{interfaceName}}
    {
        private readonly IClusterClient _client;
        private readonly string _actorId;
        private readonly string _actorType = "{{className.Replace("Actor", "")}}";

        public {{proxyName}}(IClusterClient client, string actorId)
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
            _actorId = actorId ?? throw new ArgumentNullException(nameof(actorId));
        }

{{proxyBuilder}}

        private QuarkEnvelope CreateEnvelope(string methodName, object[] parameters)
        {
            var payload = parameters.Length > 0
                ? System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(parameters)
                : Array.Empty<byte>();
            
            return new QuarkEnvelope(
                messageId: Guid.NewGuid().ToString(),
                actorId: _actorId,
                actorType: _actorType,
                methodName: methodName,
                payload: payload,
                correlationId: null
            );
        }

        private T DeserializeResponse<T>(QuarkEnvelope envelope)
        {
            if (envelope.IsError)
            {
                throw new InvalidOperationException($"Actor method failed: {envelope.ErrorMessage}");
            }

            if (envelope.ResponsePayload == null || envelope.ResponsePayload.Length == 0)
            {
                return default!;
            }

            return System.Text.Json.JsonSerializer.Deserialize<T>(envelope.ResponsePayload)!;
        }
    }
}
""";

        context.AddSource($"{proxyName}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GetReturnTypeString(IMethodSymbol method)
    {
        var returnType = method.ReturnType.ToDisplayString();
        return returnType;
    }

    private static bool IsAsyncMethod(IMethodSymbol method)
    {
        var returnType = method.ReturnType.ToDisplayString();
        return returnType.StartsWith("System.Threading.Tasks.Task") || 
               returnType.StartsWith("System.Threading.Tasks.ValueTask");
    }

    private static bool IsTaskWithoutResult(IMethodSymbol method)
    {
        var returnType = method.ReturnType.ToDisplayString();
        return returnType == "System.Threading.Tasks.Task" || 
               returnType == "System.Threading.Tasks.ValueTask";
    }

    private static string? GetTaskResultType(IMethodSymbol method)
    {
        if (method.ReturnType is not INamedTypeSymbol namedType)
            return null;

        // Check if it's Task<T> or ValueTask<T>
        if (namedType.TypeArguments.Length == 1)
        {
            return namedType.TypeArguments[0].ToDisplayString();
        }

        return null;
    }
}
