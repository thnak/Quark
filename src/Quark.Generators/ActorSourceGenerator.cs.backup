using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Quark.Generators;

/// <summary>
///     Source generator for creating AOT-compatible actor factory code.
///     Generates factory registration methods - NO REFLECTION.
/// </summary>
[Generator]
public class ActorSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Note: ActorAttribute is defined in Quark.Abstractions, not generated

        // Find all classes with the Actor attribute
        var actorClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Collect all actor classes
        var compilation = context.CompilationProvider.Combine(actorClasses.Collect());

        // Generate code for all actors at once
        context.RegisterSourceOutput(compilation,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration
               && classDeclaration.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDeclaration.AttributeLists)
        foreach (var attribute in attributeList.Attributes)
        {
            var symbolInfo = context.SemanticModel.GetSymbolInfo(attribute);
            if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeType = attributeSymbol.ContainingType;
            var fullName = attributeType.ToDisplayString();

            if (fullName == "Quark.Abstractions.ActorAttribute") return classDeclaration;
        }

        return null;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax?> actorClasses,
        SourceProductionContext context)
    {
        if (actorClasses.IsEmpty)
            return;

        var registrations = new StringBuilder();
        var moduleInitializer = new StringBuilder();

        foreach (var classDeclaration in actorClasses)
        {
            if (classDeclaration is null)
                continue;

            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

            if (classSymbol is null)
                continue;

            var className = classSymbol.Name;
            var fullClassName = classSymbol.ToDisplayString();
            var namespaceName = GetNamespace(classDeclaration);
            
            // Extract actor type name from [Actor(Name = "...")] attribute or use class name
            var actorTypeName = GetActorTypeName(classSymbol) ?? className;

            // Generate factory method for this actor
            GenerateActorFactory(context, className, fullClassName, namespaceName, classSymbol);
            
            // Generate dispatcher for this actor
            GenerateActorDispatcher(context, className, fullClassName, namespaceName, classSymbol);

            // Add to registration list with actor type name and fully qualified factory name
            // Both factory and dispatcher should use the SAME actorTypeName for consistent lookup
            registrations.AppendLine(
                $"        ActorFactoryRegistry.RegisterFactory<{fullClassName}>(\"{actorTypeName}\", {namespaceName}.{className}Factory.Create);");
            
            // Add dispatcher registration using the SAME actorTypeName as factory
            // This ensures ProxySourceGenerator's interface name matches dispatcher registration
            registrations.AppendLine(
                $"        ActorMethodDispatcherRegistry.RegisterDispatcher(\"{actorTypeName}\", new {namespaceName}.{className}Dispatcher());");
        }

        // Generate the module initializer
        var moduleInitSource = $$"""
                                 // <auto-generated/>
                                 #nullable enable
                                 using System.Runtime.CompilerServices;
                                 using Quark.Abstractions;
                                 using Quark.Core.Actors;

                                 namespace Quark.Generated
                                 {
                                     internal static class ActorFactoryInitializer
                                     {
                                         [ModuleInitializer]
                                         internal static void Initialize()
                                         {
                                 {{registrations}}
                                         }
                                     }
                                 }
                                 """;

        context.AddSource("ActorFactoryInitializer.g.cs", SourceText.From(moduleInitSource, Encoding.UTF8));
    }

    private static void GenerateActorFactory(
        SourceProductionContext context,
        string className,
        string fullClassName,
        string namespaceName,
        INamedTypeSymbol classSymbol)
    {
        // Find constructors
        var constructors = classSymbol.Constructors
            .Where(c => !c.IsStatic && c.DeclaredAccessibility == Accessibility.Public)
            .ToList();

        // Look for constructor with (string actorId, IActorFactory?, IServiceScope?)
        var threeParamCtor = constructors.FirstOrDefault(c =>
            c.Parameters.Length == 3 &&
            c.Parameters[0].Type.ToDisplayString() == "string" &&
            c.Parameters[1].Type.ToDisplayString().Contains("IActorFactory") &&
            c.Parameters[2].Type.ToDisplayString().Contains("IServiceScope"));

        // Look for constructor with (string actorId, IActorFactory?)
        var twoParamCtor = constructors.FirstOrDefault(c =>
            c.Parameters.Length == 2 &&
            c.Parameters[0].Type.ToDisplayString() == "string" &&
            c.Parameters[1].Type.ToDisplayString().Contains("IActorFactory"));

        // Look for constructor with (string actorId)
        var oneParamCtor = constructors.FirstOrDefault(c =>
            c.Parameters.Length == 1 &&
            c.Parameters[0].Type.ToDisplayString() == "string");

        string createActorBody;
        if (threeParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId, actorFactory!, serviceScope!);";
        }
        else if (twoParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId, actorFactory!);";
        }
        else if (oneParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId);";
        }
        else
        {
            // No valid constructor found - generate error
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "QUARK001",
                    "Invalid Actor Constructor",
                    $"Actor class '{className}' must have a constructor with signature (string actorId) or (string actorId, IActorFactory actorFactory) or (string actorId, IActorFactory actorFactory, IServiceScope serviceScope)",
                    "Quark.Generators",
                    DiagnosticSeverity.Error,
                    true),
                Location.None));
            return;
        }

        var source = $$"""
                       // <auto-generated/>
                       #nullable enable
                       using Quark.Abstractions;
                       using Quark.Core.Actors;
                       using Microsoft.Extensions.DependencyInjection;

                       namespace {{namespaceName}}
                       {
                           /// <summary>
                           /// AOT-friendly factory for {{className}}.
                           /// </summary>
                           internal static class {{className}}Factory
                           {
                               /// <summary>
                               /// Creates a new instance of {{className}}.
                               /// </summary>
                               public static {{fullClassName}} Create(string actorId, IActorFactory? actorFactory, IServiceScope? serviceScope)
                               {
                                   {{createActorBody}}
                               }
                           }
                       }
                       """;

        context.AddSource($"{className}Factory.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        var namespaceDeclaration = classDeclaration.Ancestors()
            .OfType<NamespaceDeclarationSyntax>()
            .FirstOrDefault();

        if (namespaceDeclaration != null)
            return namespaceDeclaration.Name.ToString();

        var fileScopedNamespace = classDeclaration.Ancestors()
            .OfType<FileScopedNamespaceDeclarationSyntax>()
            .FirstOrDefault();

        return fileScopedNamespace?.Name.ToString() ?? "Global";
    }

    private static string? GetActorTypeName(INamedTypeSymbol classSymbol)
    {
        // Find the [Actor] attribute
        var actorAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == "Quark.Abstractions.ActorAttribute");

        if (actorAttribute == null)
            return null;

        // First, check for InterfaceType property - if specified, use the fully qualified interface name
        foreach (var namedArg in actorAttribute.NamedArguments)
        {
            if (namedArg.Key == "InterfaceType" && namedArg.Value.Value is INamedTypeSymbol interfaceType)
            {
                return interfaceType.ToDisplayString();
            }
        }

        // Next, check for Name property - if specified, use it as the actor type name
        foreach (var namedArg in actorAttribute.NamedArguments)
        {
            if (namedArg.Key == "Name" && namedArg.Value.Value is string name && !string.IsNullOrWhiteSpace(name))
            {
                return name;
            }
        }

        return null;
    }

    private static void GenerateDispatcherMessageContracts(
        SourceProductionContext context,
        string messageContractPrefix,
        string namespaceName,
        List<IMethodSymbol> methods)
    {
        var source = new StringBuilder();
        source.AppendLine("// <auto-generated/>");
        source.AppendLine("#nullable enable");
        source.AppendLine();
        source.AppendLine($"namespace {namespaceName}");
        source.AppendLine("{");

        foreach (var method in methods)
        {
            var methodName = method.Name;
            var returnType = method.ReturnType.ToDisplayString();

            // Skip non-async methods - they don't need message contracts
            if (!IsAsyncReturnType(returnType))
                continue;

            // Generate request message if method has parameters (excluding CancellationToken)
            var serializableParams = method.Parameters
                .Where(p => p.Type.ToDisplayString() != "System.Threading.CancellationToken")
                .ToList();

            if (serializableParams.Count > 0)
            {
                source.AppendLine($"    /// <summary>");
                source.AppendLine($"    /// Message contract for {methodName} request.");
                source.AppendLine($"    /// </summary>");
                source.AppendLine($"    public sealed class {messageContractPrefix}_{methodName}Request");
                source.AppendLine($"    {{");

                foreach (var param in serializableParams)
                {
                    var paramType = param.Type.ToDisplayString();
                    var paramName = ToPascalCase(param.Name);

                    source.AppendLine($"        /// <summary>Gets or sets the {param.Name} parameter.</summary>");
                    source.AppendLine($"        public {paramType} {paramName} {{ get; set; }}");
                    source.AppendLine();
                }

                source.AppendLine($"    }}");
                source.AppendLine();
            }

            // Generate response message if method returns a value
            var returnTypeSymbol = method.ReturnType as INamedTypeSymbol;
            if (returnTypeSymbol != null && IsTaskWithResult(returnTypeSymbol, out var resultType))
            {
                source.AppendLine($"    /// <summary>");
                source.AppendLine($"    /// Message contract for {methodName} response.");
                source.AppendLine($"    /// </summary>");
                source.AppendLine($"    public sealed class {messageContractPrefix}_{methodName}Response");
                source.AppendLine($"    {{");
                source.AppendLine($"        /// <summary>Gets or sets the return value.</summary>");
                source.AppendLine($"        public {resultType} Result {{ get; set; }}");
                source.AppendLine($"    }}");
                source.AppendLine();
            }
        }

        source.AppendLine("}");

        context.AddSource($"{messageContractPrefix}DispatcherMessages.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
    }

    private static bool IsAsyncReturnType(string returnTypeString)
    {
        return returnTypeString == "System.Threading.Tasks.Task" ||
               returnTypeString == "System.Threading.Tasks.ValueTask" ||
               returnTypeString.StartsWith("System.Threading.Tasks.Task<") ||
               returnTypeString.StartsWith("System.Threading.Tasks.ValueTask<") ||
               returnTypeString.StartsWith("System.Collections.Generic.IAsyncEnumerable<");
    }

    private static bool IsTaskWithResult(INamedTypeSymbol taskType, out string resultType)
    {
        resultType = string.Empty;

        // Check for Task<T> or ValueTask<T>
        if (taskType.IsGenericType)
        {
            var typeDefinition = taskType.ConstructedFrom.ToDisplayString();
            if (typeDefinition == "System.Threading.Tasks.Task<TResult>" ||
                typeDefinition == "System.Threading.Tasks.ValueTask<TResult>")
            {
                resultType = taskType.TypeArguments[0].ToDisplayString();
                return true;
            }
        }

        return false;
    }

    private static string ToPascalCase(string name)
    {
        if (string.IsNullOrEmpty(name) || name.Length == 1)
            return name;

        return char.ToUpper(name[0]) + name.Substring(1);
    }

    private static void GenerateActorDispatcher(
        SourceProductionContext context,
        string className,
        string fullClassName,
        string namespaceName,
        INamedTypeSymbol classSymbol)
    {
        var methods = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Public 
                     && !m.IsStatic 
                     && m.MethodKind == MethodKind.Ordinary
                     && m.Name != "OnActivateAsync"
                     && m.Name != "OnDeactivateAsync"
                     && m.Name != "Subscribe"
                     && m.Name != "Unsubscribe")
            .ToList();

        // Get the interface symbol if InterfaceType is specified
        INamedTypeSymbol? interfaceSymbol = null;
        string? interfaceName = null;
        
        var actorAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == "Quark.Abstractions.ActorAttribute");
        
        if (actorAttribute != null)
        {
            foreach (var namedArg in actorAttribute.NamedArguments)
            {
                if (namedArg.Key == "InterfaceType" && namedArg.Value.Value is INamedTypeSymbol ifaceType)
                {
                    interfaceSymbol = ifaceType;
                    interfaceName = ifaceType.Name;
                    break;
                }
            }
        }

        // Check for overloads and report diagnostic
        var overloadGroups = methods.GroupBy(m => m.Name).Where(g => g.Count() > 1).ToList();
        if (overloadGroups.Any())
        {
            foreach (var group in overloadGroups)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "QUARK100",
                        "Method Overloading Not Fully Supported",
                        $"Actor '{className}' has multiple overloads of method '{group.Key}'. Only the first overload will be dispatched. Consider using unique method names.",
                        "Quark.Generators",
                        DiagnosticSeverity.Warning,
                        true),
                    Location.None));
            }
        }

        // Take only first overload for each method name
        var uniqueMethods = methods.GroupBy(m => m.Name).Select(g => g.First()).ToList();

        // Use interface name if available, otherwise use class name for message contract naming
        var messageContractPrefix = interfaceName ?? className;

        // Generate Protobuf message contracts for dispatcher
        GenerateDispatcherMessageContracts(context, messageContractPrefix, namespaceName, uniqueMethods);

        var dispatchCases = new StringBuilder();
        
        foreach (var method in uniqueMethods)
        {
            var methodName = method.Name;
            var returnType = method.ReturnType.ToDisplayString();
            var isAsync = returnType.StartsWith("System.Threading.Tasks.Task");
            var hasReturnValue = isAsync && returnType != "System.Threading.Tasks.Task";
            
            // Build parameter deserialization using JSON
            var parameterCode = new StringBuilder();
            var invokeArgs = new List<string>();
            var nonCancellationParams = method.Parameters.Where(p => 
                p.Type.ToDisplayString() != "System.Threading.CancellationToken").ToList();
            
            if (nonCancellationParams.Count == 0)
            {
                // No parameters - payload should be empty
                parameterCode.AppendLine("                    // No parameters");
            }
            else
            {
                // Deserialize JSON request message using unique variable name
                parameterCode.AppendLine($"                    var jsonRequest = System.Text.Json.JsonSerializer.Deserialize<{messageContractPrefix}_{methodName}Request>(payload);");
                parameterCode.AppendLine($"                    if (jsonRequest == null)");
                parameterCode.AppendLine($"                    {{");
                parameterCode.AppendLine($"                        throw new System.InvalidOperationException(\"Failed to deserialize request payload for method '{methodName}'.\");");
                parameterCode.AppendLine($"                    }}");
                
                // Extract parameters from the request message
                foreach (var param in nonCancellationParams)
                {
                    var paramName = param.Name;
                    var pascalParamName = ToPascalCase(paramName);
                    parameterCode.AppendLine($"                    var {paramName} = jsonRequest.{pascalParamName};");
                    invokeArgs.Add(paramName);
                }
            }
            
            // Add CancellationToken if the method expects it
            if (method.Parameters.Any(p => p.Type.ToDisplayString() == "System.Threading.CancellationToken"))
            {
                invokeArgs.Add("cancellationToken");
            }
            
            var invokeArgsStr = string.Join(", ", invokeArgs);
            
            // Check if this is an IAsyncEnumerable return type
            var isAsyncEnumerable = returnType.StartsWith("System.Collections.Generic.IAsyncEnumerable<");
            
            // Generate the dispatch case
            dispatchCases.AppendLine($@"                case ""{methodName}"":
                {{
{parameterCode}                    var typedActor = ({fullClassName})actor;");
            
            if (hasReturnValue)
            {
                // Extract inner type from Task<T>
                var innerType = returnType.Substring("System.Threading.Tasks.Task<".Length);
                innerType = innerType.Substring(0, innerType.Length - 1);
                
                // Serialize return value using JSON
                dispatchCases.AppendLine($@"                    var result = await typedActor.{methodName}({invokeArgsStr});");
                dispatchCases.AppendLine($@"                    var response = new {messageContractPrefix}_{methodName}Response {{ Result = result }};");
                dispatchCases.AppendLine($@"                    return System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(response);");
            }
            else if (isAsyncEnumerable)
            {
                // IAsyncEnumerable methods don't follow the request-response pattern.
                // They are invoked to start streaming, and results are pushed via separate streaming channels.
                // The dispatcher just initiates the method and returns empty payload.
                dispatchCases.AppendLine($@"                    typedActor.{methodName}({invokeArgsStr});
                    return Array.Empty<byte>();");
            }
            else if (isAsync)
            {
                dispatchCases.AppendLine($@"                    await typedActor.{methodName}({invokeArgsStr});
                    return Array.Empty<byte>();");
            }
            else
            {
                dispatchCases.AppendLine($@"                    typedActor.{methodName}({invokeArgsStr});
                    return Array.Empty<byte>();");
            }
            
            dispatchCases.AppendLine("                }");
        }

        var source = $$"""
                       // <auto-generated/>
                       #nullable enable
                       using System;
                       using System.Threading;
                       using System.Threading.Tasks;
                       using Quark.Abstractions;

                       namespace {{namespaceName}}
                       {
                           /// <summary>
                           /// AOT-friendly dispatcher for {{className}}.
                           /// </summary>
                           internal sealed class {{className}}Dispatcher : IActorMethodDispatcher
                           {
                               public Type ActorType => typeof({{fullClassName}});

                               public async Task<byte[]> InvokeAsync(
                                   IActor actor,
                                   string methodName,
                                   byte[] payload,
                                   CancellationToken cancellationToken)
                               {
                                   if (actor == null)
                                       throw new ArgumentNullException(nameof(actor));
                                   
                                   if (actor is not {{fullClassName}})
                                       throw new ArgumentException($"Expected actor of type {{fullClassName}}, but got {actor.GetType().FullName}", nameof(actor));

                                   switch (methodName)
                                   {
                       {{dispatchCases}}                default:
                                           throw new InvalidOperationException($"Method '{methodName}' not found on actor type '{{fullClassName}}'");
                                   }
                               }
                           }
                       }
                       """;

        context.AddSource($"{className}Dispatcher.g.cs", SourceText.From(source, Encoding.UTF8));
    }
}