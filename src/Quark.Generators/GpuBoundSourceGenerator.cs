using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Quark.Generators;

/// <summary>
/// Source generator for creating a static list of GPU-bound actors.
/// Generates {AssemblyName}AcceleratedActorTypes.All property - NO REFLECTION.
/// </summary>
[Generator]
public class GpuBoundSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with the GpuBound attribute
        var gpuBoundClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Collect all GPU-bound classes with assembly name
        var compilation = context.CompilationProvider.Combine(gpuBoundClasses.Collect());

        // Generate code for all GPU-bound actors at once
        context.RegisterSourceOutput(compilation,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration
               && classDeclaration.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDeclaration.AttributeLists)
        foreach (var attribute in attributeList.Attributes)
        {
            var symbolInfo = context.SemanticModel.GetSymbolInfo(attribute);
            if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeType = attributeSymbol.ContainingType;
            var fullName = attributeType.ToDisplayString();

            if (fullName == "Quark.Placement.Abstractions.GpuBoundAttribute")
                return classDeclaration;
        }

        return null;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax?> gpuBoundClasses,
        SourceProductionContext context)
    {
        if (gpuBoundClasses.IsEmpty)
            return;

        var actorTypes = new StringBuilder();
        var uniqueActorTypes = new HashSet<string>();

        foreach (var classDeclaration in gpuBoundClasses)
        {
            if (classDeclaration is null)
                continue;

            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

            if (classSymbol is null)
                continue;

            var fullClassName = classSymbol.ToDisplayString();
            
            // Avoid duplicates
            if (uniqueActorTypes.Add(fullClassName))
            {
                actorTypes.AppendLine($"            typeof({fullClassName}),");
            }
        }

        // Only generate if we found GPU-bound actors
        if (uniqueActorTypes.Count == 0)
            return;

        // Get assembly name (sanitized for valid C# identifier)
        var assemblyName = compilation.AssemblyName ?? "Assembly";
        var sanitizedAssemblyName = SanitizeIdentifier(assemblyName);

        // Generate the static class with the All property
        var source = $$"""
                       // <auto-generated/>
                       #nullable enable
                       using System;
                       using System.Collections.Generic;

                       namespace Quark.Generated
                       {
                           /// <summary>
                           /// Contains all actor types marked with [GpuBound] attribute in assembly {{assemblyName}}.
                           /// Generated at compile-time by GpuBoundSourceGenerator.
                           /// </summary>
                           public static class {{sanitizedAssemblyName}}AcceleratedActorTypes
                           {
                               /// <summary>
                               /// Gets a read-only set of all GPU-bound actor types in this assembly.
                               /// Use this in configuration: options.AcceleratedActorTypes = {{sanitizedAssemblyName}}AcceleratedActorTypes.All;
                               /// </summary>
                               public static IReadOnlySet<Type> All { get; } = new HashSet<Type>
                               {
                       {{actorTypes}}
                               };
                           }
                       }
                       """;

        context.AddSource($"{sanitizedAssemblyName}AcceleratedActorTypes.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string SanitizeIdentifier(string name)
    {
        var sb = new StringBuilder();
        foreach (var c in name)
        {
            if (char.IsLetterOrDigit(c))
                sb.Append(c);
            else
                sb.Append('_');
        }
        return sb.ToString();
    }
}
