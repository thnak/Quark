using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace Quark.Generators;

/// <summary>
/// Source generator for creating AOT-compatible actor factory code.
/// Generates factory registration methods - NO REFLECTION.
/// </summary>
[Generator]
public class ActorSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the Actor attribute source
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "ActorAttribute.g.cs",
            SourceText.From(ActorAttributeSource, Encoding.UTF8)));

        // Find all classes with the Actor attribute
        var actorClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Collect all actor classes
        var compilation = context.CompilationProvider.Combine(actorClasses.Collect());

        // Generate code for all actors at once
        context.RegisterSourceOutput(compilation,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration
            && classDeclaration.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var symbolInfo = context.SemanticModel.GetSymbolInfo(attribute);
                if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                    continue;

                var attributeType = attributeSymbol.ContainingType;
                var fullName = attributeType.ToDisplayString();

                if (fullName == "Quark.Abstractions.ActorAttribute")
                {
                    return classDeclaration;
                }
            }
        }

        return null;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax?> actorClasses,
        SourceProductionContext context)
    {
        if (actorClasses.IsEmpty)
            return;

        var registrations = new StringBuilder();
        var moduleInitializer = new StringBuilder();

        foreach (var classDeclaration in actorClasses)
        {
            if (classDeclaration is null)
                continue;

            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
            
            if (classSymbol is null)
                continue;

            var className = classSymbol.Name;
            var fullClassName = classSymbol.ToDisplayString();
            var namespaceName = GetNamespace(classDeclaration);

            // Generate factory method for this actor
            GenerateActorFactory(context, className, fullClassName, namespaceName, classSymbol);

            // Add to registration list with fully qualified factory name
            registrations.AppendLine($"        ActorFactoryRegistry.RegisterFactory<{fullClassName}>({namespaceName}.{className}Factory.Create);");
        }

        // Generate the module initializer
        var moduleInitSource = $$"""
            // <auto-generated/>
            #nullable enable
            using System.Runtime.CompilerServices;
            using Quark.Core.Actors;

            namespace Quark.Generated
            {
                internal static class ActorFactoryInitializer
                {
                    [ModuleInitializer]
                    internal static void Initialize()
                    {
            {{registrations}}
                    }
                }
            }
            """;

        context.AddSource("ActorFactoryInitializer.g.cs", SourceText.From(moduleInitSource, Encoding.UTF8));
    }

    private static void GenerateActorFactory(
        SourceProductionContext context,
        string className,
        string fullClassName,
        string namespaceName,
        INamedTypeSymbol classSymbol)
    {
        // Find constructors
        var constructors = classSymbol.Constructors
            .Where(c => !c.IsStatic && c.DeclaredAccessibility == Accessibility.Public)
            .ToList();

        // Look for constructor with (string actorId, IActorFactory?, IServiceScope?)
        var threeParamCtor = constructors.FirstOrDefault(c => 
            c.Parameters.Length == 3 &&
            c.Parameters[0].Type.ToDisplayString() == "string" &&
            c.Parameters[1].Type.ToDisplayString().Contains("IActorFactory") &&
            c.Parameters[2].Type.ToDisplayString().Contains("IServiceScope"));

        // Look for constructor with (string actorId, IActorFactory?)
        var twoParamCtor = constructors.FirstOrDefault(c =>
            c.Parameters.Length == 2 &&
            c.Parameters[0].Type.ToDisplayString() == "string" &&
            c.Parameters[1].Type.ToDisplayString().Contains("IActorFactory"));

        // Look for constructor with (string actorId)
        var oneParamCtor = constructors.FirstOrDefault(c =>
            c.Parameters.Length == 1 &&
            c.Parameters[0].Type.ToDisplayString() == "string");

        string createActorBody;
        if (threeParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId, actorFactory, serviceScope);";
        }
        else if (twoParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId, actorFactory);";
        }
        else if (oneParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId);";
        }
        else
        {
            // No valid constructor found - generate error
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "QUARK001",
                    "Invalid Actor Constructor",
                    $"Actor class '{className}' must have a constructor with signature (string actorId) or (string actorId, IActorFactory actorFactory) or (string actorId, IActorFactory actorFactory, IServiceScope serviceScope)",
                    "Quark.Generators",
                    DiagnosticSeverity.Error,
                    true),
                Location.None));
            return;
        }

        var source = $$"""
            // <auto-generated/>
            #nullable enable
            using Quark.Abstractions;
            using Quark.Core.Actors;
            using Microsoft.Extensions.DependencyInjection;

            namespace {{namespaceName}}
            {
                /// <summary>
                /// AOT-friendly factory for {{className}}.
                /// </summary>
                internal static class {{className}}Factory
                {
                    /// <summary>
                    /// Creates a new instance of {{className}}.
                    /// </summary>
                    public static {{fullClassName}} Create(string actorId, IActorFactory? actorFactory, IServiceScope? serviceScope)
                    {
                        {{createActorBody}}
                    }
                }
            }
            """;

        context.AddSource($"{className}Factory.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        var namespaceDeclaration = classDeclaration.Ancestors()
            .OfType<NamespaceDeclarationSyntax>()
            .FirstOrDefault();

        if (namespaceDeclaration != null)
            return namespaceDeclaration.Name.ToString();

        var fileScopedNamespace = classDeclaration.Ancestors()
            .OfType<FileScopedNamespaceDeclarationSyntax>()
            .FirstOrDefault();

        return fileScopedNamespace?.Name.ToString() ?? "Global";
    }

    private const string ActorAttributeSource = """
        // <auto-generated/>
        #nullable enable

        namespace Quark.Abstractions
        {
            /// <summary>
            /// Marks a class as an actor that should be code-generated for AOT compatibility.
            /// </summary>
            [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
            public sealed class ActorAttribute : System.Attribute
            {
                /// <summary>
                /// Gets or sets the name of the actor type.
                /// </summary>
                public string? Name { get; set; }

                /// <summary>
                /// Gets or sets whether this actor supports reentrancy.
                /// </summary>
                public bool Reentrant { get; set; }
            }
        }
        """;
}
