using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Quark.Generators;

/// <summary>
///     Source generator for creating AOT-compatible actor factory code.
///     Generates factory registration methods - NO REFLECTION.
/// </summary>
[Generator]
public class ActorSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Note: ActorAttribute is defined in Quark.Abstractions, not generated

        // Find all classes with the Actor attribute
        var actorClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Collect all actor classes
        var compilation = context.CompilationProvider.Combine(actorClasses.Collect());

        // Generate code for all actors at once
        context.RegisterSourceOutput(compilation,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration
               && classDeclaration.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDeclaration.AttributeLists)
        foreach (var attribute in attributeList.Attributes)
        {
            var symbolInfo = context.SemanticModel.GetSymbolInfo(attribute);
            if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeType = attributeSymbol.ContainingType;
            var fullName = attributeType.ToDisplayString();

            if (fullName == "Quark.Abstractions.ActorAttribute") return classDeclaration;
        }

        return null;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax?> actorClasses,
        SourceProductionContext context)
    {
        if (actorClasses.IsEmpty)
            return;

        var registrations = new StringBuilder();
        var moduleInitializer = new StringBuilder();

        foreach (var classDeclaration in actorClasses)
        {
            if (classDeclaration is null)
                continue;

            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

            if (classSymbol is null)
                continue;

            var className = classSymbol.Name;
            var fullClassName = classSymbol.ToDisplayString();
            var namespaceName = GetNamespace(classDeclaration);
            
            // Extract actor type name from [Actor(Name = "...")] attribute or use class name
            var actorTypeName = GetActorTypeName(classSymbol) ?? className;

            // Generate factory method for this actor
            GenerateActorFactory(context, className, fullClassName, namespaceName, classSymbol);
            
            // Generate dispatcher for this actor
            GenerateActorDispatcher(context, className, fullClassName, namespaceName, classSymbol);

            // Add to registration list with actor type name and fully qualified factory name
            registrations.AppendLine(
                $"        ActorFactoryRegistry.RegisterFactory<{fullClassName}>(\"{actorTypeName}\", {namespaceName}.{className}Factory.Create);");
            
            // Add dispatcher registration
            registrations.AppendLine(
                $"        ActorMethodDispatcherRegistry.RegisterDispatcher(\"{fullClassName}\", new {namespaceName}.{className}Dispatcher());");
        }

        // Generate the module initializer
        var moduleInitSource = $$"""
                                 // <auto-generated/>
                                 #nullable enable
                                 using System.Runtime.CompilerServices;
                                 using Quark.Abstractions;
                                 using Quark.Core.Actors;

                                 namespace Quark.Generated
                                 {
                                     internal static class ActorFactoryInitializer
                                     {
                                         [ModuleInitializer]
                                         internal static void Initialize()
                                         {
                                 {{registrations}}
                                         }
                                     }
                                 }
                                 """;

        context.AddSource("ActorFactoryInitializer.g.cs", SourceText.From(moduleInitSource, Encoding.UTF8));
    }

    private static void GenerateActorFactory(
        SourceProductionContext context,
        string className,
        string fullClassName,
        string namespaceName,
        INamedTypeSymbol classSymbol)
    {
        // Find constructors
        var constructors = classSymbol.Constructors
            .Where(c => !c.IsStatic && c.DeclaredAccessibility == Accessibility.Public)
            .ToList();

        // Look for constructor with (string actorId, IActorFactory?, IServiceScope?)
        var threeParamCtor = constructors.FirstOrDefault(c =>
            c.Parameters.Length == 3 &&
            c.Parameters[0].Type.ToDisplayString() == "string" &&
            c.Parameters[1].Type.ToDisplayString().Contains("IActorFactory") &&
            c.Parameters[2].Type.ToDisplayString().Contains("IServiceScope"));

        // Look for constructor with (string actorId, IActorFactory?)
        var twoParamCtor = constructors.FirstOrDefault(c =>
            c.Parameters.Length == 2 &&
            c.Parameters[0].Type.ToDisplayString() == "string" &&
            c.Parameters[1].Type.ToDisplayString().Contains("IActorFactory"));

        // Look for constructor with (string actorId)
        var oneParamCtor = constructors.FirstOrDefault(c =>
            c.Parameters.Length == 1 &&
            c.Parameters[0].Type.ToDisplayString() == "string");

        string createActorBody;
        if (threeParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId, actorFactory!, serviceScope!);";
        }
        else if (twoParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId, actorFactory!);";
        }
        else if (oneParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId);";
        }
        else
        {
            // No valid constructor found - generate error
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "QUARK001",
                    "Invalid Actor Constructor",
                    $"Actor class '{className}' must have a constructor with signature (string actorId) or (string actorId, IActorFactory actorFactory) or (string actorId, IActorFactory actorFactory, IServiceScope serviceScope)",
                    "Quark.Generators",
                    DiagnosticSeverity.Error,
                    true),
                Location.None));
            return;
        }

        var source = $$"""
                       // <auto-generated/>
                       #nullable enable
                       using Quark.Abstractions;
                       using Quark.Core.Actors;
                       using Microsoft.Extensions.DependencyInjection;

                       namespace {{namespaceName}}
                       {
                           /// <summary>
                           /// AOT-friendly factory for {{className}}.
                           /// </summary>
                           internal static class {{className}}Factory
                           {
                               /// <summary>
                               /// Creates a new instance of {{className}}.
                               /// </summary>
                               public static {{fullClassName}} Create(string actorId, IActorFactory? actorFactory, IServiceScope? serviceScope)
                               {
                                   {{createActorBody}}
                               }
                           }
                       }
                       """;

        context.AddSource($"{className}Factory.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        var namespaceDeclaration = classDeclaration.Ancestors()
            .OfType<NamespaceDeclarationSyntax>()
            .FirstOrDefault();

        if (namespaceDeclaration != null)
            return namespaceDeclaration.Name.ToString();

        var fileScopedNamespace = classDeclaration.Ancestors()
            .OfType<FileScopedNamespaceDeclarationSyntax>()
            .FirstOrDefault();

        return fileScopedNamespace?.Name.ToString() ?? "Global";
    }

    private static string? GetActorTypeName(INamedTypeSymbol classSymbol)
    {
        // Find the [Actor] attribute
        var actorAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == "Quark.Abstractions.ActorAttribute");

        if (actorAttribute == null)
            return null;

        // First, check for InterfaceType property - if specified, use the fully qualified interface name
        foreach (var namedArg in actorAttribute.NamedArguments)
        {
            if (namedArg.Key == "InterfaceType" && namedArg.Value.Value is INamedTypeSymbol interfaceType)
            {
                return interfaceType.ToDisplayString();
            }
        }

        // Next, check for Name property - if specified, use it as the actor type name
        foreach (var namedArg in actorAttribute.NamedArguments)
        {
            if (namedArg.Key == "Name" && namedArg.Value.Value is string name && !string.IsNullOrWhiteSpace(name))
            {
                return name;
            }
        }

        return null;
    }

    private static void GenerateActorDispatcher(
        SourceProductionContext context,
        string className,
        string fullClassName,
        string namespaceName,
        INamedTypeSymbol classSymbol)
    {
        var methods = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Public 
                     && !m.IsStatic 
                     && m.MethodKind == MethodKind.Ordinary
                     && m.Name != "OnActivateAsync"
                     && m.Name != "OnDeactivateAsync"
                     && m.Name != "Subscribe"
                     && m.Name != "Unsubscribe")
            .GroupBy(m => m.Name)  // Group by method name to handle overloads
            .Select(g => g.First())  // Take first overload (for now, simplified approach)
            .ToList();

        var dispatchCases = new StringBuilder();
        
        foreach (var method in methods)
        {
            var methodName = method.Name;
            var returnType = method.ReturnType.ToDisplayString();
            var isAsync = returnType.StartsWith("System.Threading.Tasks.Task");
            var hasReturnValue = isAsync && returnType != "System.Threading.Tasks.Task";
            
            // Build parameter deserialization
            var parameterCode = new StringBuilder();
            var invokeArgs = new List<string>();
            
            for (int i = 0; i < method.Parameters.Length; i++)
            {
                var param = method.Parameters[i];
                var paramType = param.Type.ToDisplayString();
                var paramName = param.Name;
                
                // Skip CancellationToken - we'll pass it directly
                if (paramType == "System.Threading.CancellationToken")
                {
                    invokeArgs.Add("cancellationToken");
                    continue;
                }
                
                parameterCode.AppendLine($"                var {paramName} = System.Text.Json.JsonSerializer.Deserialize<{paramType}>(payload);");
                invokeArgs.Add(paramName + "!");
            }
            
            var invokeArgsStr = string.Join(", ", invokeArgs);
            
            // Generate the dispatch case
            dispatchCases.AppendLine($@"                case ""{methodName}"":
                {{
{parameterCode}                    var typedActor = ({fullClassName})actor;");
            
            if (hasReturnValue)
            {
                // Extract inner type from Task<T>
                var innerType = returnType.Substring("System.Threading.Tasks.Task<".Length);
                innerType = innerType.Substring(0, innerType.Length - 1);
                
                dispatchCases.AppendLine($@"                    var result = await typedActor.{methodName}({invokeArgsStr});
                    return System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(result);");
            }
            else if (isAsync)
            {
                dispatchCases.AppendLine($@"                    await typedActor.{methodName}({invokeArgsStr});
                    return Array.Empty<byte>();");
            }
            else
            {
                dispatchCases.AppendLine($@"                    typedActor.{methodName}({invokeArgsStr});
                    return Array.Empty<byte>();");
            }
            
            dispatchCases.AppendLine("                }");
        }

        var source = $$"""
                       // <auto-generated/>
                       #nullable enable
                       using System;
                       using System.Threading;
                       using System.Threading.Tasks;
                       using Quark.Abstractions;

                       namespace {{namespaceName}}
                       {
                           /// <summary>
                           /// AOT-friendly dispatcher for {{className}}.
                           /// </summary>
                           internal sealed class {{className}}Dispatcher : IActorMethodDispatcher
                           {
                               public Type ActorType => typeof({{fullClassName}});

                               public async Task<byte[]> InvokeAsync(
                                   IActor actor,
                                   string methodName,
                                   byte[] payload,
                                   CancellationToken cancellationToken)
                               {
                                   if (actor == null)
                                       throw new ArgumentNullException(nameof(actor));
                                   
                                   if (actor is not {{fullClassName}})
                                       throw new ArgumentException($"Expected actor of type {{fullClassName}}, but got {actor.GetType().FullName}", nameof(actor));

                                   switch (methodName)
                                   {
                       {{dispatchCases}}                default:
                                           throw new InvalidOperationException($"Method '{methodName}' not found on actor type '{{fullClassName}}'");
                                   }
                               }
                           }
                       }
                       """;

        context.AddSource($"{className}Dispatcher.g.cs", SourceText.From(source, Encoding.UTF8));
    }
}