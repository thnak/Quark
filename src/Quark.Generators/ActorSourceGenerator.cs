using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Quark.Generators;

/// <summary>
///     Source generator for creating AOT-compatible actor factory code.
///     Generates factory registration methods - NO REFLECTION.
/// </summary>
[Generator]
public class ActorSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Note: ActorAttribute is defined in Quark.Abstractions, not generated

        // Find all classes with the Actor attribute
        var actorClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Collect all actor classes
        var compilation = context.CompilationProvider.Combine(actorClasses.Collect());

        // Generate code for all actors at once
        context.RegisterSourceOutput(compilation,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration
               && classDeclaration.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDeclaration.AttributeLists)
        foreach (var attribute in attributeList.Attributes)
        {
            var symbolInfo = context.SemanticModel.GetSymbolInfo(attribute);
            if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeType = attributeSymbol.ContainingType;
            var fullName = attributeType.ToDisplayString();

            if (fullName == "Quark.Abstractions.ActorAttribute") return classDeclaration;
        }

        return null;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax?> actorClasses,
        SourceProductionContext context)
    {
        if (actorClasses.IsEmpty)
            return;

        var registrations = new StringBuilder();
        var moduleInitializer = new StringBuilder();

        foreach (var classDeclaration in actorClasses)
        {
            if (classDeclaration is null)
                continue;

            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

            if (classSymbol is null)
                continue;

            var className = classSymbol.Name;
            var fullClassName = classSymbol.ToDisplayString();
            var namespaceName = GetNamespace(classDeclaration);
            
            // Extract actor type name from [Actor(Name = "...")] attribute or use class name
            var actorTypeName = GetActorTypeName(classSymbol) ?? className;

            // Generate factory method for this actor
            GenerateActorFactory(context, className, fullClassName, namespaceName, classSymbol);

            // Add to registration list with actor type name and fully qualified factory name
            registrations.AppendLine(
                $"        ActorFactoryRegistry.RegisterFactory<{fullClassName}>(\"{actorTypeName}\", {namespaceName}.{className}Factory.Create);");
        }

        // Generate the module initializer
        var moduleInitSource = $$"""
                                 // <auto-generated/>
                                 #nullable enable
                                 using System.Runtime.CompilerServices;
                                 using Quark.Core.Actors;

                                 namespace Quark.Generated
                                 {
                                     internal static class ActorFactoryInitializer
                                     {
                                         [ModuleInitializer]
                                         internal static void Initialize()
                                         {
                                 {{registrations}}
                                         }
                                     }
                                 }
                                 """;

        context.AddSource("ActorFactoryInitializer.g.cs", SourceText.From(moduleInitSource, Encoding.UTF8));
    }

    private static void GenerateActorFactory(
        SourceProductionContext context,
        string className,
        string fullClassName,
        string namespaceName,
        INamedTypeSymbol classSymbol)
    {
        // Find constructors
        var constructors = classSymbol.Constructors
            .Where(c => !c.IsStatic && c.DeclaredAccessibility == Accessibility.Public)
            .ToList();

        // Look for constructor with (string actorId, IActorFactory?, IServiceScope?)
        var threeParamCtor = constructors.FirstOrDefault(c =>
            c.Parameters.Length == 3 &&
            c.Parameters[0].Type.ToDisplayString() == "string" &&
            c.Parameters[1].Type.ToDisplayString().Contains("IActorFactory") &&
            c.Parameters[2].Type.ToDisplayString().Contains("IServiceScope"));

        // Look for constructor with (string actorId, IActorFactory?)
        var twoParamCtor = constructors.FirstOrDefault(c =>
            c.Parameters.Length == 2 &&
            c.Parameters[0].Type.ToDisplayString() == "string" &&
            c.Parameters[1].Type.ToDisplayString().Contains("IActorFactory"));

        // Look for constructor with (string actorId)
        var oneParamCtor = constructors.FirstOrDefault(c =>
            c.Parameters.Length == 1 &&
            c.Parameters[0].Type.ToDisplayString() == "string");

        string createActorBody;
        if (threeParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId, actorFactory!, serviceScope!);";
        }
        else if (twoParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId, actorFactory!);";
        }
        else if (oneParamCtor != null)
        {
            createActorBody = $"return new {fullClassName}(actorId);";
        }
        else
        {
            // No valid constructor found - generate error
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "QUARK001",
                    "Invalid Actor Constructor",
                    $"Actor class '{className}' must have a constructor with signature (string actorId) or (string actorId, IActorFactory actorFactory) or (string actorId, IActorFactory actorFactory, IServiceScope serviceScope)",
                    "Quark.Generators",
                    DiagnosticSeverity.Error,
                    true),
                Location.None));
            return;
        }

        var source = $$"""
                       // <auto-generated/>
                       #nullable enable
                       using Quark.Abstractions;
                       using Quark.Core.Actors;
                       using Microsoft.Extensions.DependencyInjection;

                       namespace {{namespaceName}}
                       {
                           /// <summary>
                           /// AOT-friendly factory for {{className}}.
                           /// </summary>
                           internal static class {{className}}Factory
                           {
                               /// <summary>
                               /// Creates a new instance of {{className}}.
                               /// </summary>
                               public static {{fullClassName}} Create(string actorId, IActorFactory? actorFactory, IServiceScope? serviceScope)
                               {
                                   {{createActorBody}}
                               }
                           }
                       }
                       """;

        context.AddSource($"{className}Factory.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        var namespaceDeclaration = classDeclaration.Ancestors()
            .OfType<NamespaceDeclarationSyntax>()
            .FirstOrDefault();

        if (namespaceDeclaration != null)
            return namespaceDeclaration.Name.ToString();

        var fileScopedNamespace = classDeclaration.Ancestors()
            .OfType<FileScopedNamespaceDeclarationSyntax>()
            .FirstOrDefault();

        return fileScopedNamespace?.Name.ToString() ?? "Global";
    }

    private static string? GetActorTypeName(INamedTypeSymbol classSymbol)
    {
        // Find the [Actor] attribute
        var actorAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == "Quark.Abstractions.ActorAttribute");

        if (actorAttribute == null)
            return null;

        // First, check for InterfaceType property - if specified, use the fully qualified interface name
        foreach (var namedArg in actorAttribute.NamedArguments)
        {
            if (namedArg.Key == "InterfaceType" && namedArg.Value.Value is INamedTypeSymbol interfaceType)
            {
                return interfaceType.ToDisplayString();
            }
        }

        // Next, check for Name property - if specified, use it as the actor type name
        foreach (var namedArg in actorAttribute.NamedArguments)
        {
            if (namedArg.Key == "Name" && namedArg.Value.Value is string name && !string.IsNullOrWhiteSpace(name))
            {
                return name;
            }
        }

        return null;
    }
}