using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Quark.SourceGenerator
{
    /// <summary>
    /// Source generator for creating AOT-compatible actor factory code.
    /// </summary>
    [Generator]
    public class ActorSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register the attribute source
            context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
                "ActorAttribute.g.cs",
                SourceText.From(AttributeSource, Encoding.UTF8)));

            // Find all classes with the Actor attribute
            var actorClasses = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null);

            // Generate code for each actor class
            context.RegisterSourceOutput(actorClasses,
                static (spc, source) => Execute(source, spc));
        }

        private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax classDeclaration
                && classDeclaration.AttributeLists.Count > 0;
        }

        private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;

            foreach (var attributeList in classDeclaration.AttributeLists)
            {
                foreach (var attribute in attributeList.Attributes)
                {
                    var symbolInfo = context.SemanticModel.GetSymbolInfo(attribute);
                    if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                        continue;

                    var attributeType = attributeSymbol.ContainingType;
                    var fullName = attributeType.ToDisplayString();

                    if (fullName == "Quark.Core.ActorAttribute")
                    {
                        return classDeclaration;
                    }
                }
            }

            return null;
        }

        private static void Execute(ClassDeclarationSyntax? classDeclaration, SourceProductionContext context)
        {
            if (classDeclaration is null)
                return;

            var className = classDeclaration.Identifier.Text;
            var namespaceName = GetNamespace(classDeclaration);

            var source = $$"""
                // <auto-generated/>
                #nullable enable

                namespace {{namespaceName}}
                {
                    /// <summary>
                    /// AOT-friendly factory extension for {{className}}.
                    /// </summary>
                    public static partial class {{className}}Factory
                    {
                        /// <summary>
                        /// Creates a new instance of {{className}}.
                        /// </summary>
                        public static {{className}} Create(string actorId)
                        {
                            return new {{className}}(actorId);
                        }
                    }
                }
                """;

            context.AddSource($"{className}Factory.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
        {
            var namespaceDeclaration = classDeclaration.Ancestors()
                .OfType<NamespaceDeclarationSyntax>()
                .FirstOrDefault();

            if (namespaceDeclaration != null)
                return namespaceDeclaration.Name.ToString();

            var fileScopedNamespace = classDeclaration.Ancestors()
                .OfType<FileScopedNamespaceDeclarationSyntax>()
                .FirstOrDefault();

            return fileScopedNamespace?.Name.ToString() ?? "Global";
        }

        private const string AttributeSource = """
            // <auto-generated/>
            #nullable enable

            namespace Quark.Core
            {
                /// <summary>
                /// Marks a class as an actor that should be code-generated for AOT compatibility.
                /// </summary>
                [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                public sealed class ActorAttribute : System.Attribute
                {
                    /// <summary>
                    /// Gets or sets the name of the actor type.
                    /// </summary>
                    public string? Name { get; set; }

                    /// <summary>
                    /// Gets or sets whether this actor supports reentrancy.
                    /// </summary>
                    public bool Reentrant { get; set; }
                }
            }
            """;
    }
}
