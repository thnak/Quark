# Source Generators in Quark

Quark achieves 100% reflection-free operation through extensive use of Roslyn source generators. This page explains how source generation works and why it's critical for Native AOT compatibility.

## Why Source Generation?

### The Problem with Reflection

Traditional .NET frameworks use reflection for:
- Creating instances dynamically (`Activator.CreateInstance`)
- Discovering types at runtime (`Assembly.GetTypes()`)
- Serializing objects (`JsonSerializer` with reflection)
- Generating proxy code (`DispatchProxy.Create`)

**Problems:**
- ❌ Not compatible with Native AOT
- ❌ Runtime performance overhead
- ❌ Larger binary sizes (metadata required)
- ❌ Startup time penalty
- ❌ Security concerns

### The Quark Solution

Quark moves all "magic" to **compile-time**:
- ✅ Source generators analyze code during compilation
- ✅ Generated code is type-safe and efficient
- ✅ No runtime discovery or reflection
- ✅ Native AOT compatible
- ✅ Fully traceable (generated code visible in IDE)

## Quark's Source Generators

### 1. Actor Source Generator

**Location**: `src/Quark.Generators/ActorSourceGenerator.cs`

**Purpose**: Generates factory methods for actors marked with `[Actor]` attribute.

#### What You Write

```csharp
[Actor(Name = "Counter", Reentrant = false)]
public class CounterActor : ActorBase
{
    public CounterActor(string actorId) : base(actorId)
    {
    }
}
```

#### What Gets Generated

```csharp
// <auto-generated/>
using System.Runtime.CompilerServices;

namespace Quark.Generated
{
    public static class CounterActorFactory
    {
        public static CounterActor Create(
            string actorId, 
            IActorFactory? actorFactory = null)
        {
            return new CounterActor(actorId, actorFactory);
        }
    }

    public static class ActorRegistrationModule
    {
        [ModuleInitializer]
        public static void Initialize()
        {
            ActorRegistry.RegisterFactory(
                typeof(CounterActor), 
                (id, factory) => CounterActorFactory.Create(id, factory));
        }
    }
}
```

**Benefits:**
- No reflection when creating actors
- Module initializer auto-registers factories at startup
- Supports constructor dependency injection
- Fully AOT-compatible

### 2. State Source Generator

**Location**: `src/Quark.Generators/StateSourceGenerator.cs`

**Purpose**: Generates Load/Save/Delete methods for state properties marked with `[QuarkState]`.

#### What You Write

```csharp
public class UserActor : StatefulActorBase
{
    [QuarkState]
    public UserProfile? Profile { get; set; }

    [QuarkState]
    public UserSettings? Settings { get; set; }
}
```

#### What Gets Generated

```csharp
// <auto-generated/>
partial class UserActor
{
    protected override async Task LoadStateAsync(CancellationToken ct = default)
    {
        if (_stateStorageProvider == null) return;

        // Load Profile
        var profileStorage = _stateStorageProvider.GetStorage<UserProfile>("default");
        Profile = await profileStorage.LoadAsync($"{ActorId}:Profile", ct);

        // Load Settings
        var settingsStorage = _stateStorageProvider.GetStorage<UserSettings>("default");
        Settings = await settingsStorage.LoadAsync($"{ActorId}:Settings", ct);
    }

    protected override async Task SaveStateAsync(CancellationToken ct = default)
    {
        if (_stateStorageProvider == null) return;

        // Save Profile
        if (Profile != null)
        {
            var profileStorage = _stateStorageProvider.GetStorage<UserProfile>("default");
            await profileStorage.SaveAsync($"{ActorId}:Profile", Profile, ct);
        }

        // Save Settings
        if (Settings != null)
        {
            var settingsStorage = _stateStorageProvider.GetStorage<UserSettings>("default");
            await settingsStorage.SaveAsync($"{ActorId}:Settings", Settings, ct);
        }
    }

    protected override async Task DeleteStateAsync(CancellationToken ct = default)
    {
        if (_stateStorageProvider == null) return;

        // Delete Profile
        var profileStorage = _stateStorageProvider.GetStorage<UserProfile>("default");
        await profileStorage.DeleteAsync($"{ActorId}:Profile", ct);

        // Delete Settings
        var settingsStorage = _stateStorageProvider.GetStorage<UserSettings>("default");
        await settingsStorage.DeleteAsync($"{ActorId}:Settings", ct);
    }
}
```

**Benefits:**
- No reflection for state persistence
- Type-safe storage operations
- Compile-time validation
- Multiple state properties supported

### 3. Stream Source Generator

**Location**: `src/Quark.Generators/StreamSourceGenerator.cs`

**Purpose**: Registers stream subscriptions for actors marked with `[QuarkStream]`.

#### What You Write

```csharp
[Actor]
[QuarkStream("orders/new")]
public class OrderProcessorActor : ActorBase, IStreamConsumer<Order>
{
    public async Task OnStreamMessageAsync(
        Order message, 
        StreamId streamId, 
        CancellationToken ct = default)
    {
        // Process order
    }
}
```

#### What Gets Generated

```csharp
// <auto-generated/>
using System.Runtime.CompilerServices;

namespace Quark.Generated
{
    public static class StreamRegistrationModule
    {
        [ModuleInitializer]
        public static void Initialize()
        {
            StreamRegistry.RegisterImplicitSubscription(
                "orders/new",
                typeof(OrderProcessorActor),
                typeof(Order));
        }
    }
}
```

**Benefits:**
- Stream routing resolved at compile-time
- No runtime stream discovery
- Type-safe message delivery
- Auto-registration via module initializer

### 4. Logging Source Generator

**Location**: `src/Quark.Generators.Logging/LoggerMessageSourceGenerator.cs`

**Purpose**: Generates high-performance logging methods using `LoggerMessage.Define` pattern.

#### What You Write

```csharp
public partial class MyActor
{
    [QuarkLoggerMessage(LogLevel.Information, "Actor {ActorId} activated")]
    private partial void LogActorActivated(ILogger logger, string actorId);

    [QuarkLoggerMessage(LogLevel.Error, "Failed to process {MessageId}")]
    private partial void LogProcessingFailed(ILogger logger, string messageId, Exception ex);
}
```

#### What Gets Generated

```csharp
// <auto-generated/>
partial class MyActor
{
    private static readonly Action<ILogger, string, Exception?> _logActorActivatedAction =
        LoggerMessage.Define<string>(
            LogLevel.Information,
            new EventId(1, nameof(LogActorActivated)),
            "Actor {ActorId} activated");

    private partial void LogActorActivated(ILogger logger, string actorId)
    {
        _logActorActivatedAction(logger, actorId, null);
    }

    private static readonly Action<ILogger, string, Exception?> _logProcessingFailedAction =
        LoggerMessage.Define<string>(
            LogLevel.Error,
            new EventId(2, nameof(LogProcessingFailed)),
            "Failed to process {MessageId}");

    private partial void LogProcessingFailed(ILogger logger, string messageId, Exception ex)
    {
        _logProcessingFailedAction(logger, messageId, ex);
    }
}
```

**Benefits:**
- Zero-allocation logging
- No string interpolation overhead
- Compile-time message validation
- Structured logging support

## Setting Up Source Generators

### Critical: Explicit References Required

Source generator references are **NOT transitive**. You must explicitly reference them in every project that uses them.

### In Your Project File

```xml
<Project Sdk="Microsoft.NET.Sdk">
  
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <!-- Reference the framework -->
    <ProjectReference Include="path/to/Quark.Core/Quark.Core.csproj" />
    
    <!-- REQUIRED: Explicit generator reference -->
    <ProjectReference Include="path/to/Quark.Generators/Quark.Generators.csproj" 
                      OutputItemType="Analyzer" 
                      ReferenceOutputAssembly="false" />
    
    <!-- Optional: Logging generator -->
    <ProjectReference Include="path/to/Quark.Generators.Logging/Quark.Generators.Logging.csproj"
                      OutputItemType="Analyzer"
                      ReferenceOutputAssembly="false" />
  </ItemGroup>

</Project>
```

**Key Points:**
- `OutputItemType="Analyzer"` - Marks it as a source generator
- `ReferenceOutputAssembly="false"` - Don't reference the generator's DLL
- Must be in **every** project that defines actors

### Why Explicit References?

Unlike regular project references, analyzers and source generators don't flow transitively:

```
Your Project
    ↓ references
Quark.Core
    ↓ references (but doesn't propagate!)
Quark.Generators ⚠️
```

Without explicit reference in your project:
- ❌ No generated code
- ❌ Runtime error: "No factory registered for actor type"
- ❌ Actors won't work

## Viewing Generated Code

### In Visual Studio

1. **Solution Explorer** → Expand project
2. **Dependencies** → **Analyzers** → **Quark.Generators**
3. See generated files like `ActorFactory.g.cs`

### In File System

Generated files are in:
```
obj/Debug/net10.0/generated/Quark.Generators/
├── ActorFactory.g.cs
├── StateGeneration.g.cs
└── StreamRegistration.g.cs
```

### Example Generated File

```csharp
// <auto-generated>
// This code was generated by Quark.Generators.ActorSourceGenerator
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

#nullable enable

using System;
using System.Runtime.CompilerServices;
using Quark.Abstractions;

namespace Quark.Generated
{
    /// <summary>
    /// Generated factory for CounterActor
    /// </summary>
    public static class CounterActorFactory
    {
        public static CounterActor Create(string actorId, IActorFactory? actorFactory = null)
        {
            return new CounterActor(actorId, actorFactory);
        }
    }
}
```

## How Source Generation Works

### Compilation Pipeline

```
Your Code (.cs files)
      ↓
   Roslyn Compiler
      ↓
Source Generator Analysis
      ↓
Generated Code (.g.cs files)
      ↓
Combined Compilation
      ↓
Final Assembly
```

### Incremental Generation

Quark uses **Incremental Source Generators** (ISG):
- ✅ Fast - only regenerates when inputs change
- ✅ Efficient - caches intermediate results
- ✅ Scales - handles large codebases
- ✅ IDE-friendly - minimal impact on IntelliSense

### Generation Triggers

Code is regenerated when:
- Adding/removing `[Actor]` attribute
- Changing actor constructor
- Adding/removing `[QuarkState]` properties
- Changing `[QuarkStream]` namespace
- Modifying logging methods

## JSON Serialization

Quark uses System.Text.Json's built-in source generator for serialization.

### Define a Serialization Context

```csharp
using System.Text.Json.Serialization;

[JsonSerializable(typeof(SiloInfo))]
[JsonSerializable(typeof(ActorLocation))]
[JsonSerializable(typeof(ClusterMembershipSnapshot))]
internal partial class QuarkJsonSerializerContext : JsonSerializerContext
{
}
```

### Use the Context

```csharp
var options = new JsonSerializerOptions
{
    TypeInfoResolver = QuarkJsonSerializerContext.Default
};

// Serialize (zero reflection)
var json = JsonSerializer.Serialize(silo, options);

// Deserialize (zero reflection)
var silo = JsonSerializer.Deserialize<SiloInfo>(json, options);
```

**Benefits:**
- No reflection during serialization
- Faster than reflection-based serialization
- Smaller AOT binaries (no metadata)
- Compile-time validation

## AOT Compatibility

### What Makes It AOT-Compatible?

1. **No Dynamic Code**: Everything generated at compile-time
2. **No Reflection**: All types known statically
3. **No IL Emission**: No runtime code generation
4. **Known Types**: All types reachable from entry point

### Testing AOT Compatibility

```bash
# Publish with AOT
dotnet publish -c Release -r linux-x64 -p:PublishAot=true

# Should succeed with minimal warnings
```

### Expected Warnings

```
IL3058: Microsoft.Extensions.DependencyInjection.Abstractions...
```

These warnings are about third-party libraries and are **safe to ignore**. They don't prevent AOT compilation or cause runtime issues.

### Forbidden Patterns

These patterns will **break** AOT:

```csharp
// ❌ Don't use Activator
var actor = (IActor)Activator.CreateInstance(actorType);

// ❌ Don't use dynamic
dynamic obj = GetActor();
obj.Process();

// ❌ Don't use reflection
var method = type.GetMethod("Process");
method.Invoke(actor, null);

// ❌ Don't use expression trees at runtime
Expression<Func<int, int>> expr = x => x * 2;
var compiled = expr.Compile(); // Will fail

// ✅ Use source generation instead
var actor = factory.CreateActor<MyActor>("id");
```

## Debugging Source Generators

### Enable Verbose Output

Add to your `.csproj`:

```xml
<PropertyGroup>
  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
  <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)Generated</CompilerGeneratedFilesOutputPath>
</PropertyGroup>
```

### Common Issues

#### Generator Not Running

**Symptom**: No generated files in `obj/`

**Solutions:**
1. Clean and rebuild: `dotnet clean && dotnet build`
2. Check generator reference has `OutputItemType="Analyzer"`
3. Verify generator project builds successfully
4. Check for compilation errors in consuming project

#### Duplicate Attribute Warnings

**Symptom**: CS0436 warnings about `ActorAttribute` being defined multiple times

**Cause**: Each project gets its own copy of attributes

**Solution**: These warnings are harmless - you can suppress them:
```xml
<PropertyGroup>
  <NoWarn>$(NoWarn);CS0436</NoWarn>
</PropertyGroup>
```

#### Generated Code Not Updating

**Symptom**: Changes to attributes don't reflect in generated code

**Solutions:**
1. Clean solution: `dotnet clean`
2. Delete `obj/` and `bin/` directories
3. Restart IDE
4. Check incremental build settings

## Performance Impact

### Compile-Time

Source generation adds minimal overhead:
- **First build**: +2-5 seconds
- **Incremental build**: +0.1-0.5 seconds
- **IDE responsiveness**: Minimal impact

### Runtime

Generated code is **faster** than reflection:
- **Actor creation**: 10-100x faster (direct instantiation vs Activator)
- **Serialization**: 2-3x faster (no reflection)
- **Logging**: Zero allocation vs boxing/allocation
- **State access**: Direct property access

## Best Practices

### 1. Keep Generators Simple

Don't put complex logic in attributes:

```csharp
// ✅ Good: Simple attribute
[Actor(Name = "Counter", Reentrant = false)]

// ❌ Avoid: Complex logic in attributes
[Actor(
    Name = SomeHelper.GetActorName(), 
    Reentrant = Environment.GetEnvironmentVariable("REENTRANT") == "true")]
```

### 2. Use Partial Classes

Make classes `partial` if you plan to extend generated code:

```csharp
// ✅ Good: Partial class
[Actor]
public partial class MyActor : ActorBase
{
    // Your code here
}

// Generated code in another file
partial class MyActor
{
    // Generated code here
}
```

### 3. Don't Edit Generated Files

Generated files are recreated on every build:

```csharp
// ❌ Don't edit files marked <auto-generated>
// Your changes will be lost!
```

### 4. Check Generated Code Into Source Control?

**No** - Generated files should be in `.gitignore`:

```gitignore
obj/
bin/
*.g.cs
```

Only check in **source** files, not generated ones.

### 5. Document Generator Requirements

In your README, document the generator setup:

```markdown
## Setup

⚠️ Important: This project requires explicit source generator references:

```xml
<ProjectReference Include="path/to/Quark.Generators/Quark.Generators.csproj"
                  OutputItemType="Analyzer"
                  ReferenceOutputAssembly="false" />
```
```

## Comparison to Other Approaches

| Approach | AOT Compatible | Performance | Type Safety | Complexity |
|----------|---------------|-------------|-------------|------------|
| **Source Generation** | ✅ Yes | ✅ Fast | ✅ Full | ⚠️ Medium |
| **Reflection** | ❌ No | ⚠️ Slow | ⚠️ Runtime | ✅ Low |
| **IL Weaving** | ⚠️ Partial | ✅ Fast | ✅ Full | ❌ High |
| **Manual Code** | ✅ Yes | ✅ Fast | ✅ Full | ❌ Very High |

Source generation strikes the best balance for Quark's needs.

## Further Reading

- **[Getting Started](Getting-Started)** - Setup with generators
- **[Actor Model](Actor-Model)** - How actors use generation
- **[Persistence](Persistence)** - State generation details
- **[Streaming](Streaming)** - Stream registration generation

---

**Related**: [FAQ](FAQ) | [API Reference](API-Reference) | [Contributing](Contributing)
