# Persistence in Quark

Quark provides a flexible, high-performance persistence system that enables actors to store and retrieve state with **zero reflection** through compile-time source generation. State survives restarts, failures, and migrations across cluster nodes.

## Table of Contents

- [Why Persistence?](#why-persistence)
- [State Management Basics](#state-management-basics)
- [Stateful Actors](#stateful-actors)
- [Storage Backends](#storage-backends)
- [Optimistic Concurrency](#optimistic-concurrency)
- [JSON Serialization for AOT](#json-serialization-for-aot)
- [Configuration](#configuration)
- [State Lifecycle](#state-lifecycle)
- [Best Practices](#best-practices)
- [Migration Between Backends](#migration-between-backends)
- [Performance Considerations](#performance-considerations)
- [Troubleshooting](#troubleshooting)

---

## Why Persistence?

Actor persistence enables:

- **Durability**: State survives process restarts and crashes
- **Recovery**: Actors resume with their last known state after failures
- **Migration**: Actors move between nodes while retaining state
- **Scalability**: Offload memory by storing state in external systems
- **Compliance**: Meet audit and regulatory requirements

**When to use persistence:**
- Financial transactions, user profiles, shopping carts
- Long-running workflows that span multiple requests
- Stateful business logic that must survive failures
- Distributed systems requiring strong consistency

**When NOT to use persistence:**
- Transient, throwaway data (use in-memory state)
- High-frequency updates where latency matters more than durability
- Data that can be easily recomputed or fetched from other sources

---

## State Management Basics

Quark uses the **`[QuarkState]` attribute** and **source generation** to provide compile-time, reflection-free state persistence.

### The `[QuarkState]` Attribute

Mark any property on a `StatefulActorBase` with `[QuarkState]` to enable automatic persistence:

```csharp
using Quark.Abstractions.Persistence;
using Quark.Core.Actors;

public partial class ShoppingCartActor : StatefulActorBase
{
    // Automatically persisted to the "default" storage provider
    [QuarkState("default")]
    public CartState? Cart { get; set; }
    
    // Persist to a different backend (e.g., cache vs database)
    [QuarkState("redis-cache", Name = "UserPreferences")]
    public UserPreferences? Preferences { get; set; }
    
    public ShoppingCartActor(string actorId, IActorFactory? actorFactory, IServiceScope? serviceScope)
        : base(actorId, actorFactory, serviceScope)
    {
    }
}

public class CartState
{
    public List<CartItem> Items { get; set; } = new();
    public decimal Total { get; set; }
    public DateTime LastModified { get; set; }
}
```

### How Source Generation Works

At **compile-time**, the `StateSourceGenerator` generates:

1. **Load methods**: `LoadCartAsync()`, `LoadPreferencesAsync()`
2. **Save methods**: `SaveCartAsync()`, `SavePreferencesAsync()`
3. **Delete methods**: `DeleteCartAsync()`, `DeletePreferencesAsync()`
4. **JsonSerializerContext**: AOT-compatible JSON serialization for each state type

**Generated code example:**

```csharp
// Auto-generated by StateSourceGenerator
partial class ShoppingCartActor
{
    private long? _CartVersion;

    public async Task LoadCartAsync(CancellationToken cancellationToken = default)
    {
        var storage = GetStorage<CartState>("default");
        var result = await storage.LoadWithVersionAsync(ActorId, "Cart", cancellationToken);
        if (result != null)
        {
            Cart = result.State;
            _CartVersion = result.Version;
        }
        else
        {
            Cart = new CartState();
            _CartVersion = null; // First save will create version 1
        }
    }

    public async Task SaveCartAsync(CancellationToken cancellationToken = default)
    {
        if (Cart == null)
            throw new InvalidOperationException("Cannot save null state 'Cart'.");
        
        var storage = GetStorage<CartState>("default");
        _CartVersion = await storage.SaveWithVersionAsync(
            ActorId, "Cart", Cart, _CartVersion, cancellationToken);
    }

    public async Task DeleteCartAsync(CancellationToken cancellationToken = default)
    {
        var storage = GetStorage<CartState>("default");
        await storage.DeleteAsync(ActorId, "Cart", cancellationToken);
        Cart = null;
        _CartVersion = null;
    }
}
```

**Key Points:**
- **Zero reflection**: All code is generated at compile-time
- **AOT-compatible**: Works with Native AOT compilation
- **Version tracking**: Automatic optimistic concurrency control
- **Type-safe**: Compile-time errors for misconfigurations

---

## Stateful Actors

### StatefulActorBase

Inherit from `StatefulActorBase` to enable state persistence:

```csharp
using Quark.Abstractions;
using Quark.Core.Actors;
using Quark.Abstractions.Persistence;

[Actor(Name = "BankAccount")]
public partial class BankAccountActor : StatefulActorBase
{
    [QuarkState("postgres-db")]
    public AccountState? Account { get; set; }

    public BankAccountActor(string actorId, IActorFactory? actorFactory, IServiceScope? serviceScope)
        : base(actorId, actorFactory, serviceScope)
    {
    }

    public override async Task OnActivateAsync(CancellationToken cancellationToken = default)
    {
        await base.OnActivateAsync(cancellationToken);
        
        // Load persisted state
        await LoadAccountAsync(cancellationToken);
        
        // Initialize if new
        if (Account == null || Account.AccountNumber == null)
        {
            Account = new AccountState
            {
                AccountNumber = ActorId,
                Balance = 0m,
                CreatedAt = DateTime.UtcNow
            };
            await SaveAccountAsync(cancellationToken);
        }
    }

    public async Task<decimal> DepositAsync(decimal amount, CancellationToken cancellationToken = default)
    {
        if (amount <= 0)
            throw new ArgumentException("Amount must be positive", nameof(amount));

        Account!.Balance += amount;
        Account.LastModified = DateTime.UtcNow;
        
        // Persist the change
        await SaveAccountAsync(cancellationToken);
        
        return Account.Balance;
    }

    public async Task<decimal> WithdrawAsync(decimal amount, CancellationToken cancellationToken = default)
    {
        if (amount <= 0)
            throw new ArgumentException("Amount must be positive", nameof(amount));
        
        if (Account!.Balance < amount)
            throw new InvalidOperationException("Insufficient funds");

        Account.Balance -= amount;
        Account.LastModified = DateTime.UtcNow;
        
        await SaveAccountAsync(cancellationToken);
        
        return Account.Balance;
    }
}

public class AccountState
{
    public string AccountNumber { get; set; } = "";
    public decimal Balance { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime LastModified { get; set; }
}
```

### Key Methods

| Method | Purpose | When to Call |
|--------|---------|-------------|
| `Load{Property}Async()` | Load state from storage | `OnActivateAsync()` or on-demand |
| `Save{Property}Async()` | Save state to storage | After modifying state |
| `Delete{Property}Async()` | Remove state from storage | Actor decommissioning |

---

## Storage Backends

Quark supports **9 storage backends** out of the box:

### 1. InMemoryStateStorage

**Use Case:** Development, testing, caching

**Characteristics:**
- ‚úÖ Fastest performance (microsecond latency)
- ‚úÖ Zero configuration
- ‚úÖ Full optimistic concurrency support
- ‚ùå Data lost on restart
- ‚ùå Not suitable for production

**Configuration:**

```csharp
using Quark.Core.Persistence;

var storageProvider = new StateStorageProvider();
storageProvider.RegisterStorage("default", stateType =>
{
    var genericType = typeof(InMemoryStateStorage<>).MakeGenericType(stateType);
    return Activator.CreateInstance(genericType)!;
});
```

---

### 2. RedisStateStorage

**Use Case:** Distributed caching, fast access, session state

**Characteristics:**
- ‚úÖ Sub-millisecond latency
- ‚úÖ Built-in replication and persistence
- ‚úÖ Redis Cluster support for horizontal scaling
- ‚úÖ Atomic operations via Lua scripts
- ‚ùå Limited to data that fits in memory (unless using Redis on Flash)

**Configuration:**

```csharp
using Quark.Storage.Redis;
using StackExchange.Redis;

var redis = ConnectionMultiplexer.Connect("localhost:6379");
var database = redis.GetDatabase();

storageProvider.RegisterStorage("redis-cache", stateType =>
{
    var genericType = typeof(RedisStateStorage<>).MakeGenericType(stateType);
    return Activator.CreateInstance(genericType, database, null)!;
});
```

**NuGet Package:**

```bash
dotnet add package Quark.Storage.Redis
dotnet add package StackExchange.Redis
```

**Redis Keys:**

```
quark:state:{actorId}:{stateName}
  - state: (JSON serialized state)
  - version: (optimistic concurrency version)
```

---

### 3. PostgresStateStorage

**Use Case:** Relational data, complex queries, JSONB indexing

**Characteristics:**
- ‚úÖ ACID transactions
- ‚úÖ JSONB column type for efficient queries
- ‚úÖ Full SQL query capabilities
- ‚úÖ Strong consistency guarantees
- ‚ö†Ô∏è Higher latency than Redis (~5-20ms)

**Configuration:**

```csharp
using Quark.Storage.Postgres;

var connectionString = "Host=localhost;Database=quark;Username=postgres;Password=secret";

storageProvider.RegisterStorage("postgres-db", stateType =>
{
    var genericType = typeof(PostgresStateStorage<>).MakeGenericType(stateType);
    var storage = Activator.CreateInstance(genericType, connectionString, "quark_state", null)!;
    
    // Initialize schema on first use
    var initMethod = genericType.GetMethod("InitializeSchemaAsync");
    initMethod?.Invoke(storage, new object[] { CancellationToken.None });
    
    return storage;
});
```

**NuGet Package:**

```bash
dotnet add package Quark.Storage.Postgres
dotnet add package Npgsql
```

**Schema:**

```sql
CREATE TABLE quark_state (
    actor_id VARCHAR(255) NOT NULL,
    state_name VARCHAR(255) NOT NULL,
    state_data JSONB NOT NULL,
    version BIGINT NOT NULL DEFAULT 1,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (actor_id, state_name)
);
CREATE INDEX idx_quark_state_updated_at ON quark_state(updated_at);
```

**Query JSONB:**

```sql
-- Find all accounts with balance > 1000
SELECT actor_id, state_data->>'Balance' AS balance
FROM quark_state
WHERE state_name = 'Account'
  AND (state_data->>'Balance')::decimal > 1000;
```

---

### 4. SQL Server (SqlServerStateStorage)

**Use Case:** Enterprise applications, Windows environments, Azure

**Characteristics:**
- ‚úÖ Enterprise-grade features (Always On, partitioning)
- ‚úÖ JSON support (NVARCHAR(MAX))
- ‚úÖ Automatic retry policies with Polly
- ‚úÖ Azure SQL Database support
- ‚ö†Ô∏è Licensing costs for production

**Configuration:**

```csharp
using Quark.Storage.SqlServer;

var connectionString = "Server=localhost;Database=Quark;User Id=sa;Password=YourPassword123;";

storageProvider.RegisterStorage("sqlserver-db", stateType =>
{
    var genericType = typeof(SqlServerStateStorage<>).MakeGenericType(stateType);
    var storage = Activator.CreateInstance(genericType, connectionString, "QuarkState", null, null)!;
    
    // Initialize schema
    var initMethod = genericType.GetMethod("InitializeSchemaAsync");
    initMethod?.Invoke(storage, new object[] { CancellationToken.None });
    
    return storage;
});
```

**NuGet Package:**

```bash
dotnet add package Quark.Storage.SqlServer
dotnet add package Microsoft.Data.SqlClient
```

---

### 5. MongoDB (MongoDbStateStorage)

**Use Case:** Document-oriented data, flexible schemas, horizontal scaling

**Characteristics:**
- ‚úÖ Native BSON serialization (efficient for complex objects)
- ‚úÖ Flexible schema evolution
- ‚úÖ Sharding support for massive scale
- ‚úÖ Rich query language
- ‚ö†Ô∏è Eventual consistency by default (configure read/write concerns)

**Configuration:**

```csharp
using Quark.Storage.MongoDB;
using MongoDB.Driver;

var client = new MongoClient("mongodb://localhost:27017");
var database = client.GetDatabase("quark");

storageProvider.RegisterStorage("mongodb", stateType =>
{
    var genericType = typeof(MongoDbStateStorage<>).MakeGenericType(stateType);
    var storage = Activator.CreateInstance(genericType, database, "quark_state")!;
    
    // Initialize indexes
    var initMethod = genericType.GetMethod("InitializeIndexesAsync");
    initMethod?.Invoke(storage, new object[] { CancellationToken.None });
    
    return storage;
});
```

**NuGet Package:**

```bash
dotnet add package Quark.Storage.MongoDB
dotnet add package MongoDB.Driver
```

---

### 6. DynamoDB (DynamoDbStateStorage)

**Use Case:** AWS-native, serverless, global tables, pay-per-request

**Characteristics:**
- ‚úÖ Fully managed (no servers to provision)
- ‚úÖ Global tables for multi-region replication
- ‚úÖ On-demand billing (pay only for what you use)
- ‚úÖ Automatic scaling
- ‚ö†Ô∏è Higher latency than Redis (~10-30ms)
- ‚ö†Ô∏è AWS-specific (vendor lock-in)

**Configuration:**

```csharp
using Quark.Storage.DynamoDB;
using Amazon.DynamoDBv2;

var dynamoClient = new AmazonDynamoDBClient();

storageProvider.RegisterStorage("dynamodb", stateType =>
{
    var genericType = typeof(DynamoDbStateStorage<>).MakeGenericType(stateType);
    var storage = Activator.CreateInstance(genericType, dynamoClient, "QuarkState", null)!;
    
    // Initialize table
    var initMethod = genericType.GetMethod("InitializeTableAsync");
    initMethod?.Invoke(storage, new object[] { null, true, CancellationToken.None });
    
    return storage;
});
```

**NuGet Package:**

```bash
dotnet add package Quark.Storage.DynamoDB
dotnet add package AWSSDK.DynamoDBv2
```

---

### 7. Cassandra (CassandraStateStorage)

**Use Case:** Multi-datacenter, massive scale, time-series data

**Characteristics:**
- ‚úÖ Linear scalability (add nodes without downtime)
- ‚úÖ Multi-datacenter replication
- ‚úÖ Tunable consistency (LOCAL_QUORUM, QUORUM, etc.)
- ‚úÖ No single point of failure
- ‚ö†Ô∏è Eventually consistent by default
- ‚ö†Ô∏è Complex cluster management

**Configuration:**

```csharp
using Quark.Storage.Cassandra;
using Cassandra;

var cluster = Cluster.Builder()
    .AddContactPoint("localhost")
    .Build();
var session = cluster.Connect();

storageProvider.RegisterStorage("cassandra", stateType =>
{
    var genericType = typeof(CassandraStateStorage<>).MakeGenericType(stateType);
    var storage = Activator.CreateInstance(
        genericType, 
        session, 
        "quark",           // keyspace
        "state",           // table
        ConsistencyLevel.LocalQuorum,  // read consistency
        ConsistencyLevel.LocalQuorum,  // write consistency
        null)!;
    
    // Initialize schema
    var initMethod = genericType.GetMethod("InitializeSchemaAsync");
    initMethod?.Invoke(storage, new object[] { 
        "{'class': 'NetworkTopologyStrategy', 'datacenter1': 3}", 
        CancellationToken.None 
    });
    
    return storage;
});
```

**NuGet Package:**

```bash
dotnet add package Quark.Storage.Cassandra
dotnet add package CassandraCSharpDriver
```

---

### 8. Event Sourcing (EventSourcedActor)

**Use Case:** Audit trails, event replay, temporal queries, CQRS

**Characteristics:**
- ‚úÖ Complete audit history (every change is an event)
- ‚úÖ Time-travel queries (replay to any point in time)
- ‚úÖ Event replay for debugging and testing
- ‚úÖ Supports snapshots for performance
- ‚ö†Ô∏è More complex than state persistence
- ‚ö†Ô∏è Higher storage costs (stores all events)

**Event-Sourced Actor:**

```csharp
using Quark.EventSourcing;

public class BankAccountEventSourcedActor : EventSourcedActor
{
    private decimal _balance;
    
    protected override string ActorId => _accountId;
    private readonly string _accountId;

    public BankAccountEventSourcedActor(string accountId, IEventStore eventStore)
        : base(eventStore)
    {
        _accountId = accountId;
    }

    public async Task DepositAsync(decimal amount)
    {
        if (amount <= 0) throw new ArgumentException("Amount must be positive");
        
        RaiseEvent(new MoneyDepositedEvent { Amount = amount });
        await CommitEventsAsync();
    }

    public async Task WithdrawAsync(decimal amount)
    {
        if (amount <= 0) throw new ArgumentException("Amount must be positive");
        if (_balance < amount) throw new InvalidOperationException("Insufficient funds");
        
        RaiseEvent(new MoneyWithdrawnEvent { Amount = amount });
        await CommitEventsAsync();
    }

    protected override void Apply(DomainEvent @event)
    {
        switch (@event)
        {
            case MoneyDepositedEvent deposited:
                _balance += deposited.Amount;
                break;
            case MoneyWithdrawnEvent withdrawn:
                _balance -= withdrawn.Amount;
                break;
        }
    }

    protected override object CreateSnapshot() => new { Balance = _balance };

    protected override void ApplySnapshot(object snapshot)
    {
        var state = (dynamic)snapshot;
        _balance = state.Balance;
    }
}

public class MoneyDepositedEvent : DomainEvent
{
    public decimal Amount { get; set; }
}

public class MoneyWithdrawnEvent : DomainEvent
{
    public decimal Amount { get; set; }
}
```

**Event Store Implementations:**

```csharp
using Quark.EventSourcing;

// In-memory (testing)
var eventStore = new InMemoryEventStore();

// TODO: Redis and Postgres event stores are available in:
// - Quark.EventSourcing.Redis
// - Quark.EventSourcing.Postgres
```

**NuGet Package:**

```bash
dotnet add package Quark.EventSourcing
```

---

### 9. Custom Storage (IStateStorage<T>)

Implement `IStateStorage<T>` for custom backends:

```csharp
using Quark.Abstractions.Persistence;

public class MyCustomStateStorage<TState> : IStateStorage<TState> where TState : class
{
    public Task<StateWithVersion<TState>?> LoadWithVersionAsync(
        string actorId, string stateName, CancellationToken cancellationToken = default)
    {
        // Your implementation
    }

    public Task<long> SaveWithVersionAsync(
        string actorId, string stateName, TState state, long? expectedVersion, 
        CancellationToken cancellationToken = default)
    {
        // Your implementation with optimistic concurrency check
    }

    public Task DeleteAsync(
        string actorId, string stateName, CancellationToken cancellationToken = default)
    {
        // Your implementation
    }

    // Obsolete methods (implement for backward compatibility)
    [Obsolete]
    public Task<TState?> LoadAsync(string actorId, string stateName, CancellationToken cancellationToken = default)
        => throw new NotImplementedException("Use LoadWithVersionAsync");

    [Obsolete]
    public Task SaveAsync(string actorId, string stateName, TState state, CancellationToken cancellationToken = default)
        => throw new NotImplementedException("Use SaveWithVersionAsync");
}
```

---

### Storage Backend Comparison

| Backend | Latency | Scalability | Consistency | Complexity | Cost |
|---------|---------|-------------|-------------|------------|------|
| **InMemory** | < 1 ¬µs | Single node | Strong | Low | Free |
| **Redis** | 1-5 ms | Horizontal (cluster) | Strong | Low | $ |
| **Postgres** | 5-20 ms | Vertical + read replicas | ACID | Medium | $$ |
| **SQL Server** | 5-20 ms | Vertical + Always On | ACID | Medium | $$$ |
| **MongoDB** | 5-15 ms | Horizontal (sharding) | Eventual/Strong | Medium | $$ |
| **DynamoDB** | 10-30 ms | Unlimited | Eventual/Strong | Low | Pay-per-request |
| **Cassandra** | 5-15 ms | Unlimited | Tunable | High | $$$ |
| **Event Sourcing** | Varies | Backend-dependent | Strong | High | Backend cost + storage |

---

## Optimistic Concurrency

Quark uses **version numbers (ETags)** for optimistic concurrency control to prevent lost updates.

### How It Works

1. **Load**: Retrieve state with its version
2. **Modify**: Change state in-memory
3. **Save**: Attempt to save with the original version
4. **Conflict Detection**: Storage checks if version matches
   - ‚úÖ **Match**: Save succeeds, version increments
   - ‚ùå **Mismatch**: Throw `ConcurrencyException`

### Handling Conflicts

```csharp
using Quark.Abstractions.Persistence;

public async Task UpdateBalanceWithRetryAsync(decimal amount)
{
    const int maxRetries = 3;
    int attempt = 0;
    
    while (attempt < maxRetries)
    {
        try
        {
            await LoadAccountAsync();
            Account!.Balance += amount;
            await SaveAccountAsync();
            return; // Success!
        }
        catch (ConcurrencyException ex)
        {
            attempt++;
            if (attempt >= maxRetries)
            {
                throw new InvalidOperationException(
                    $"Failed to update after {maxRetries} attempts due to concurrent modifications", ex);
            }
            
            // Exponential backoff
            await Task.Delay(TimeSpan.FromMilliseconds(50 * Math.Pow(2, attempt)));
        }
    }
}
```

### Version Information

```csharp
public class ConcurrencyException : Exception
{
    public long? ExpectedVersion { get; }  // Version you tried to save with
    public long? ActualVersion { get; }    // Current version in storage
}
```

**Conflict Resolution Strategies:**

| Strategy | Use Case |
|----------|----------|
| **Retry** | Increment counter, append to list |
| **Abort** | Critical operation, manual intervention needed |
| **Last-Write-Wins** | Acceptable for non-critical data |
| **Merge** | Complex logic (e.g., merge shopping carts) |

---

## JSON Serialization for AOT

Quark uses **System.Text.Json with source generation** for reflection-free, AOT-compatible serialization.

### Auto-Generated JsonSerializerContext

The `StateSourceGenerator` automatically creates a `JsonSerializerContext` for each state property:

```csharp
// Auto-generated
[JsonSerializable(typeof(CartState))]
[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]
internal partial class CartJsonContext : JsonSerializerContext
{
}
```

### Manual JsonSerializerContext

For complex scenarios, define your own:

```csharp
using System.Text.Json.Serialization;

[JsonSerializable(typeof(MyComplexState))]
[JsonSerializable(typeof(List<MyComplexState>))]
[JsonSourceGenerationOptions(
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,
    WriteIndented = false,
    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]
public partial class MyStateJsonContext : JsonSerializerContext
{
}
```

Then pass it to storage:

```csharp
var jsonOptions = new JsonSerializerOptions
{
    TypeInfoResolver = MyStateJsonContext.Default
};

var storage = new PostgresStateStorage<MyComplexState>(connectionString, "quark_state", jsonOptions);
```

### AOT Compatibility Rules

‚úÖ **Allowed:**
- Properties with public getters/setters
- Simple types (int, string, DateTime, etc.)
- Collections (List<T>, Dictionary<K,V>)
- Nested objects

‚ùå **Not Allowed:**
- Reflection-based serialization
- Private fields (unless annotated)
- Circular references
- Polymorphism without explicit configuration

---

## Configuration

### Dependency Injection Setup

```csharp
using Microsoft.Extensions.DependencyInjection;
using Quark.Core.Persistence;
using Quark.Storage.Postgres;
using Quark.Storage.Redis;

var services = new ServiceCollection();

// Register storage provider
services.AddSingleton<IStateStorageProvider>(sp =>
{
    var provider = new StateStorageProvider();
    
    // Redis for fast access
    var redis = ConnectionMultiplexer.Connect("localhost:6379");
    provider.RegisterStorage("redis-cache", stateType =>
    {
        var genericType = typeof(RedisStateStorage<>).MakeGenericType(stateType);
        return Activator.CreateInstance(genericType, redis.GetDatabase(), null)!;
    });
    
    // Postgres for durable storage
    var pgConnectionString = "Host=localhost;Database=quark;Username=postgres;Password=secret";
    provider.RegisterStorage("postgres-db", stateType =>
    {
        var genericType = typeof(PostgresStateStorage<>).MakeGenericType(stateType);
        return Activator.CreateInstance(genericType, pgConnectionString, "quark_state", null)!;
    });
    
    return provider;
});

// Register actor factory
services.AddSingleton<IActorFactory, ActorFactory>();

var serviceProvider = services.BuildServiceProvider();
```

### Multi-Backend Configuration

Use different backends for different state properties:

```csharp
public partial class OrderActor : StatefulActorBase
{
    // Hot data (frequently accessed) -> Redis
    [QuarkState("redis-cache")]
    public OrderSummary? Summary { get; set; }
    
    // Audit trail (rarely accessed) -> Postgres
    [QuarkState("postgres-db")]
    public List<OrderEvent>? History { get; set; }
    
    // Temporary data -> In-memory
    [QuarkState("in-memory")]
    public ValidationResult? ValidationCache { get; set; }
}
```

---

## State Lifecycle

### Automatic State Loading

State is typically loaded in `OnActivateAsync()`:

```csharp
public override async Task OnActivateAsync(CancellationToken cancellationToken = default)
{
    await base.OnActivateAsync(cancellationToken);
    
    // Load all state properties
    await LoadCartAsync(cancellationToken);
    await LoadPreferencesAsync(cancellationToken);
    
    // Initialize if new
    if (Cart == null)
    {
        Cart = new CartState();
        await SaveCartAsync(cancellationToken);
    }
}
```

### Manual State Saving

Save state explicitly after modifications:

```csharp
public async Task AddItemAsync(string productId, int quantity)
{
    Cart!.Items.Add(new CartItem { ProductId = productId, Quantity = quantity });
    Cart.LastModified = DateTime.UtcNow;
    
    // Persist immediately
    await SaveCartAsync();
}
```

### Lazy Loading

Load state on first access:

```csharp
private bool _cartLoaded;

public async Task<CartState> GetCartAsync()
{
    if (!_cartLoaded)
    {
        await LoadCartAsync();
        _cartLoaded = true;
    }
    return Cart ?? new CartState();
}
```

### State Cleanup

Delete state when actor is decommissioned:

```csharp
public override async Task OnDeactivateAsync(CancellationToken cancellationToken = default)
{
    // Save any pending changes
    if (Cart != null)
    {
        await SaveCartAsync(cancellationToken);
    }
    
    // Optionally delete temporary state
    await DeleteValidationCacheAsync(cancellationToken);
    
    await base.OnDeactivateAsync(cancellationToken);
}
```

---

## Best Practices

### 1. State Design

‚úÖ **Keep state small and focused**

```csharp
// Good: Small, focused state
public class CartState
{
    public List<CartItem> Items { get; set; } = new();
    public decimal Total { get; set; }
}

// Bad: Bloated state
public class MegaState
{
    public Cart Cart { get; set; }
    public User User { get; set; }
    public List<Product> AllProducts { get; set; } // Don't store entire catalog!
    public byte[] LargeFile { get; set; }         // Don't store files in state
}
```

‚úÖ **Use multiple state properties for separation**

```csharp
public partial class UserActor : StatefulActorBase
{
    [QuarkState("redis-cache")]   // Hot data
    public UserProfile? Profile { get; set; }
    
    [QuarkState("postgres-db")]   // Cold data
    public List<OrderHistory>? Orders { get; set; }
}
```

‚úÖ **Avoid circular references**

```csharp
// Bad: Circular reference
public class Order
{
    public Customer Customer { get; set; }
}

public class Customer
{
    public List<Order> Orders { get; set; } // Circular!
}

// Good: Use IDs for relationships
public class Order
{
    public string CustomerId { get; set; }
}
```

### 2. Serialization

‚úÖ **Use properties, not fields**

```csharp
// Good
public class CartState
{
    public List<CartItem> Items { get; set; } = new();
}

// Bad (requires JsonInclude attribute for fields)
public class CartState
{
    private List<CartItem> _items = new(); // Won't serialize by default
}
```

‚úÖ **Avoid complex inheritance hierarchies**

```csharp
// Good: Flat structure
public class CartState
{
    public List<CartItem> Items { get; set; } = new();
}

// Bad: Deep inheritance
public abstract class BaseState { }
public class IntermediateState : BaseState { }
public class CartState : IntermediateState { } // Complicates serialization
```

### 3. Performance

‚úÖ **Save only when necessary**

```csharp
// Good: Batch updates
public async Task UpdateCartAsync(List<CartItem> items)
{
    foreach (var item in items)
    {
        Cart!.Items.Add(item);
    }
    Cart.LastModified = DateTime.UtcNow;
    
    // Single save operation
    await SaveCartAsync();
}

// Bad: Save in loop
public async Task UpdateCartAsync(List<CartItem> items)
{
    foreach (var item in items)
    {
        Cart!.Items.Add(item);
        await SaveCartAsync(); // Inefficient!
    }
}
```

‚úÖ **Use appropriate storage backend**

```csharp
// Hot path: Redis
[QuarkState("redis-cache")]
public SessionState? Session { get; set; }

// Cold path: Postgres
[QuarkState("postgres-db")]
public AuditLog? Audit { get; set; }
```

### 4. Error Handling

‚úÖ **Handle concurrency conflicts gracefully**

```csharp
try
{
    await SaveCartAsync();
}
catch (ConcurrencyException ex)
{
    // Reload and retry
    await LoadCartAsync();
    // Reapply changes or notify user
}
```

‚úÖ **Use try-catch for storage failures**

```csharp
try
{
    await LoadAccountAsync();
}
catch (Exception ex)
{
    // Log error
    _logger.LogError(ex, "Failed to load account state for {ActorId}", ActorId);
    
    // Initialize with defaults
    Account = new AccountState();
}
```

### 5. Testing

‚úÖ **Use InMemoryStateStorage for tests**

```csharp
[Fact]
public async Task TestAccountDeposit()
{
    var storageProvider = new StateStorageProvider();
    storageProvider.RegisterStorage("default", stateType =>
    {
        var genericType = typeof(InMemoryStateStorage<>).MakeGenericType(stateType);
        return Activator.CreateInstance(genericType)!;
    });
    
    var actor = new BankAccountActor("account-123", null, CreateServiceScope(storageProvider));
    await actor.OnActivateAsync();
    
    var balance = await actor.DepositAsync(100m);
    
    Assert.Equal(100m, balance);
}
```

---

## Migration Between Backends

### Strategy 1: Dual-Write

Write to both old and new backends during migration:

```csharp
public async Task SaveStateAsync()
{
    // Write to new backend
    await SaveCartAsync();
    
    // Also write to old backend (temporary)
    await SaveToLegacySystemAsync(Cart);
}
```

### Strategy 2: Offline Migration

Export and import data:

```csharp
// Export from Redis
var redis = ConnectionMultiplexer.Connect("localhost:6379");
var keys = redis.GetServer("localhost:6379").Keys(pattern: "quark:state:*");

foreach (var key in keys)
{
    var data = redis.GetDatabase().HashGet(key, "state");
    // Parse and insert into Postgres
}
```

### Strategy 3: Lazy Migration

Migrate data on access:

```csharp
public override async Task OnActivateAsync(CancellationToken cancellationToken = default)
{
    await base.OnActivateAsync(cancellationToken);
    
    // Try new storage first
    await LoadCartAsync(cancellationToken);
    
    if (Cart == null)
    {
        // Fallback to old storage
        Cart = await LoadFromLegacySystemAsync(ActorId);
        
        if (Cart != null)
        {
            // Migrate to new storage
            await SaveCartAsync(cancellationToken);
            await DeleteFromLegacySystemAsync(ActorId);
        }
    }
}
```

---

## Performance Considerations

### Latency Comparison (Typical)

| Backend | Read Latency | Write Latency | Throughput |
|---------|--------------|---------------|------------|
| InMemory | < 1 ¬µs | < 1 ¬µs | 1M+ ops/sec |
| Redis | 1-5 ms | 1-5 ms | 100K ops/sec |
| Postgres | 5-20 ms | 10-30 ms | 10K ops/sec |
| MongoDB | 5-15 ms | 10-25 ms | 20K ops/sec |
| DynamoDB | 10-30 ms | 15-40 ms | Unlimited* |
| Cassandra | 5-15 ms | 5-15 ms | 100K+ ops/sec |

*With auto-scaling

### Optimization Tips

1. **Batch operations** - Save multiple states in one transaction (if backend supports it)
2. **Use Redis for hot data** - Cache frequently accessed state
3. **Enable compression** - Reduce network transfer time
4. **Use connection pooling** - Reuse database connections
5. **Monitor version conflicts** - High conflict rates indicate contention
6. **Consider read replicas** - For read-heavy workloads

### Cost Comparison (Monthly, ~1M operations)

| Backend | Self-Hosted | Managed Service |
|---------|-------------|-----------------|
| Redis | ~$50 (EC2 + storage) | ~$200 (ElastiCache) |
| Postgres | ~$100 (EC2 + storage) | ~$300 (RDS) |
| MongoDB | ~$100 (EC2 + storage) | ~$400 (Atlas) |
| DynamoDB | N/A | ~$10-50 (on-demand) |
| Cassandra | ~$300 (3-node cluster) | ~$1000 (managed) |

---

## Troubleshooting

### Problem: ConcurrencyException on every save

**Cause:** Multiple actors or threads modifying the same state concurrently

**Solution:**
```csharp
// Implement retry logic with exponential backoff
const int maxRetries = 3;
for (int i = 0; i < maxRetries; i++)
{
    try
    {
        await SaveCartAsync();
        break;
    }
    catch (ConcurrencyException)
    {
        if (i == maxRetries - 1) throw;
        await Task.Delay(TimeSpan.FromMilliseconds(50 * Math.Pow(2, i)));
        await LoadCartAsync(); // Reload latest state
    }
}
```

### Problem: State not persisting

**Symptoms:** State resets after restart

**Checklist:**
- ‚úÖ Actor inherits from `StatefulActorBase`
- ‚úÖ Property has `[QuarkState]` attribute
- ‚úÖ Class is marked `partial`
- ‚úÖ Storage provider is registered
- ‚úÖ `SaveStateAsync()` is called after modifications
- ‚úÖ Storage backend is correctly configured

### Problem: Serialization errors with AOT

**Error:** `System.InvalidOperationException: Reflection-based serialization is not supported`

**Solution:** Define JsonSerializerContext:

```csharp
[JsonSerializable(typeof(MyState))]
[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]
public partial class MyStateJsonContext : JsonSerializerContext
{
}

var jsonOptions = new JsonSerializerOptions
{
    TypeInfoResolver = MyStateJsonContext.Default
};

var storage = new RedisStateStorage<MyState>(database, jsonOptions);
```

### Problem: High storage costs

**Symptoms:** Large bills from cloud provider

**Solutions:**
1. **Use compression** - Compress state before storing
2. **TTL/Expiration** - Set expiration on old data
3. **Archival** - Move old state to cheaper storage (S3, Glacier)
4. **State trimming** - Remove unnecessary fields from state

```csharp
// Enable compression (example with custom storage)
var compressedState = Compress(JsonSerializer.Serialize(state));
await storage.SaveAsync(actorId, stateName, compressedState);
```

### Problem: Slow state loading

**Symptoms:** High latency on actor activation

**Solutions:**
1. **Use faster backend** - Redis instead of Postgres for hot data
2. **Connection pooling** - Reuse database connections
3. **Lazy loading** - Load state on first access, not activation
4. **Caching** - Cache in-memory after first load

```csharp
// Lazy loading pattern
private CartState? _cartCache;
private bool _cartLoaded;

public async Task<CartState> GetCartAsync()
{
    if (!_cartLoaded)
    {
        await LoadCartAsync();
        _cartCache = Cart;
        _cartLoaded = true;
    }
    return _cartCache ?? new CartState();
}
```

### Problem: Version mismatch after restart

**Symptoms:** `ConcurrencyException` immediately after loading state

**Cause:** Version not properly reset after load

**Solution:** Ensure generated code tracks version correctly (this should be automatic)

### Problem: Cannot find generated methods

**Error:** `'ShoppingCartActor' does not contain a definition for 'LoadCartAsync'`

**Checklist:**
- ‚úÖ Class is marked `partial`
- ‚úÖ Property has `[QuarkState]` attribute
- ‚úÖ Quark.Generators package is referenced
- ‚úÖ Project has been rebuilt (Clean + Rebuild)
- ‚úÖ Check `obj/Generated` folder for generated files

---

## Related Topics

- **[Actor Model](Actor-Model.md)** - Core actor concepts
- **[Clustering](Clustering.md)** - Distributed actor placement
- **[Supervision](Supervision.md)** - Fault tolerance and recovery
- **[Source Generators](Source-Generators.md)** - How code generation works
- **[API Reference](API-Reference.md)** - IStateStorage<T> interface documentation

---

## Next Steps

1. **Try InMemoryStateStorage** - Quick testing and prototyping
2. **Configure Redis** - For production caching layer
3. **Set up Postgres** - For durable, queryable state
4. **Implement optimistic concurrency** - Handle conflicts gracefully
5. **Monitor performance** - Track latency, throughput, and version conflicts

**Happy persisting!** üéâ
