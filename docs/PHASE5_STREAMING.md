# Phase 5: Reactive Streaming

This document describes the reactive streaming implementation in Quark, which provides a decoupled messaging pattern where actors can produce and consume data without direct knowledge of each other.

## Overview

Quark Streams enable:
- **Implicit Subscriptions**: Actors automatically wake up when data arrives on a specific stream namespace
- **Explicit Pub/Sub**: Dynamic subscriptions that can be created and destroyed at runtime
- **Multiple Subscribers**: Many consumers can subscribe to the same stream
- **Type-Safe**: Full generic type support with AOT compatibility

## Architecture

### Core Components

1. **`StreamId`**: Unique identifier combining namespace and key
   ```csharp
   var streamId = new StreamId("orders/processed", "order-123");
   ```

2. **`IQuarkStreamProvider`**: Service for accessing streams
   ```csharp
   IStreamHandle<string> stream = provider.GetStream<string>("namespace", "key");
   ```

3. **`IStreamHandle<T>`**: Handle for publishing and subscribing
   ```csharp
   await stream.PublishAsync(message);
   var subscription = await stream.SubscribeAsync(msg => HandleMessage(msg));
   ```

4. **`QuarkStreamAttribute`**: Marks actors for implicit subscriptions
   ```csharp
   [QuarkStream("orders/processed")]
   public class OrderProcessorActor : ActorBase, IStreamConsumer<OrderMessage>
   ```

## Usage Examples

### Implicit Subscriptions (Auto-Activation)

Actors can automatically subscribe to streams using the `[QuarkStream]` attribute:

```csharp
[Actor(Name = "OrderProcessor")]
[QuarkStream("orders/processed")]
public class OrderProcessorActor : ActorBase, IStreamConsumer<OrderMessage>
{
    public OrderProcessorActor(string actorId) : base(actorId) { }

    public async Task OnStreamMessageAsync(
        OrderMessage message, 
        StreamId streamId, 
        CancellationToken cancellationToken = default)
    {
        // Process the order
        Console.WriteLine($"Processing order {message.OrderId}");
        await Task.CompletedTask;
    }
}
```

When a message is published to the `orders/processed` namespace:
1. The source generator creates a mapping from namespace to actor type
2. The `StreamBroker` activates the appropriate actor using the stream key as actor ID
3. The actor's `OnStreamMessageAsync` method is invoked with the message

### Explicit Pub/Sub (Dynamic)

For scenarios where subscriptions change at runtime:

```csharp
var streamProvider = new QuarkStreamProvider(actorFactory);

// Get a stream handle
var stream = streamProvider.GetStream<string>("events/system", "server-1");

// Subscribe with a callback
var subscription = await stream.SubscribeAsync(async message =>
{
    Console.WriteLine($"Received: {message}");
    await Task.CompletedTask;
});

// Publish messages
await stream.PublishAsync("Server started");
await stream.PublishAsync("Database connected");

// Unsubscribe when done
await subscription.UnsubscribeAsync();
```

### Multiple Subscribers

Multiple handlers can subscribe to the same stream:

```csharp
var stream = provider.GetStream<string>("chat/lobby", "lobby-1");

// Subscriber 1
var sub1 = await stream.SubscribeAsync(async msg =>
{
    Console.WriteLine($"[Logger] {msg}");
});

// Subscriber 2
var sub2 = await stream.SubscribeAsync(async msg =>
{
    Console.WriteLine($"[Processor] {msg}");
});

// All subscribers receive the message
await stream.PublishAsync("User joined");
```

## Source Generator

The `StreamSourceGenerator` automatically:
1. Detects classes with `[QuarkStream]` attributes
2. Extracts the stream namespace and message type
3. Generates a `StreamRegistrationModule` that registers mappings at startup

Example generated code:
```csharp
// <auto-generated/>
public static class StreamRegistrationModule
{
    [ModuleInitializer]
    public static void Initialize()
    {
        StreamRegistry.RegisterImplicitSubscription(
            "orders/processed", 
            typeof(OrderProcessorActor), 
            typeof(OrderMessage));
    }
}
```

## Implementation Details

### StreamBroker

The `StreamBroker` manages implicit subscriptions:
- Maintains a map of namespace â†’ actor types
- When a message is published, activates actors and delivers messages
- Uses reflection to invoke `OnStreamMessageAsync`

### StreamHandle

The `StreamHandle<T>` provides:
- In-memory pub/sub for explicit subscriptions
- Integration with `StreamBroker` for implicit subscriptions
- Thread-safe subscription management

### StreamRegistry

The global registry:
- Stores the `StreamBroker` instance
- Called by source-generated code to register mappings
- Provides access to the broker for runtime operations

## Testing

See `tests/Quark.Tests/` for comprehensive tests:
- `StreamAbstractionsTests.cs`: Tests for `StreamId`, `QuarkStreamAttribute`
- `QuarkStreamProviderTests.cs`: Tests for explicit pub/sub
- `StreamBrokerTests.cs`: Tests for implicit subscriptions and broker

All 26 tests pass successfully.

## Running the Example

```bash
cd examples/Quark.Examples.Streaming
dotnet run
```

The example demonstrates:
1. Implicit subscriptions with auto-activation
2. Explicit pub/sub with dynamic subscriptions
3. Multiple subscribers on the same stream

## Future Enhancements

Potential future improvements:
- **Backpressure**: Adaptive flow control for slow consumers
- **Persistent Streams**: Durable message storage
- **Stream Processors**: Built-in transformations and filters
- **Distributed Streams**: Cross-silo stream coordination
- **Enhanced Analyzers**: Additional compile-time validation rules for complex scenarios

## Related Documentation

- [Phase 1: Core Actor Abstractions](../PROGRESS.md)
- [Phase 2: Cluster & Networking](../PROGRESS.md)
- [Phase 3: Reliability & Supervision](../PROGRESS.md)
- [Phase 4: Persistence & Temporal Services](PHASE4_SUMMARY.md)
