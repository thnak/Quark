# AOT and JSON Serialization in Quark

## Overview

Quark uses System.Text.Json for serializing actor method parameters and return values. This provides good AOT (Ahead-of-Time) compatibility for most scenarios.

## Current Implementation

The generated actor proxies and dispatchers use `JsonSerializer.SerializeToUtf8Bytes()` and `JsonSerializer.Deserialize()` with default options. This approach:

- ✅ Works immediately without additional configuration
- ✅ Supports all common .NET types (primitives, strings, collections, DTOs)
- ✅ Is AOT-compatible for simple types
- ⚠️ May use reflection for complex types with custom converters

## AOT Compatibility Levels

### Level 1: Basic AOT (Current - No Action Required)

For simple actor interfaces using primitives, strings, and basic DTOs:

```csharp
public interface ICounterActor : IQuarkActor
{
    Task<int> GetCountAsync();
    Task IncrementAsync(int value);
}
```

**AOT Status**: ✅ Fully compatible, no warnings

### Level 2: Complex Types (May Need Attention)

For actors using complex types, polymorphic types, or custom converters:

```csharp
public interface IOrderActor : IQuarkActor
{
    Task<OrderResult> ProcessOrderAsync(OrderRequest request);
}

public class OrderRequest
{
    public string OrderId { get; set; }
    public List<OrderItem> Items { get; set; }
    public Dictionary<string, object> Metadata { get; set; } // ⚠️ May use reflection
}
```

**AOT Status**: ⚠️ Works, but may have IL warnings for `Dictionary<string, object>`

### Level 3: Optimized AOT (Manual Setup)

For maximum AOT optimization and zero reflection, you can create a custom JsonSerializerContext.

## Creating a Custom JsonSerializerContext (Optional)

If you need maximum AOT performance or want to eliminate all reflection warnings, create a JsonSerializerContext in your project:

### Step 1: Define Your Context

```csharp
using System.Text.Json.Serialization;

namespace MyApp.Serialization;

// Include all types used in your actor interfaces
[JsonSerializable(typeof(OrderRequest))]
[JsonSerializable(typeof(OrderResult))]
[JsonSerializable(typeof(OrderItem))]
[JsonSourceGenerationOptions(
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,
    GenerationMode = JsonSourceGenerationMode.Metadata)]
public partial class MyActorJsonContext : JsonSerializerContext
{
}
```

### Step 2: Use in Your Application

Currently, Quark's generated code uses default JsonSerializer options. In a future update, we plan to support custom contexts through configuration:

```csharp
// Planned API (not yet implemented)
builder.Services.AddQuarkClient(options =>
{
    options.JsonSerializerContext = MyActorJsonContext.Default;
});
```

## Why Can't Quark Generate the JsonSerializerContext?

You might wonder why Quark doesn't automatically generate a complete JsonSerializerContext. The reason is a fundamental limitation of Roslyn source generators:

**System.Text.Json's source generator does not process code generated by other source generators in the same compilation.**

This means:
1. Quark's generator creates message classes
2. Quark's generator creates a partial JsonSerializerContext with [JsonSerializable] attributes
3. System.Text.Json's generator needs to complete the partial class
4. ❌ But System.Text.Json's generator doesn't see Quark's generated code

This is a known limitation in the Roslyn pipeline and affects all source generators that try to interact with each other.

## Workaround Strategies

### Strategy 1: Default Serialization (Current)
- Use JsonSerializer with default options
- Best for: Most applications, rapid development
- Trade-off: May use reflection for complex types

### Strategy 2: Manual Context
- Create your own JsonSerializerContext in a separate file
- Best for: Production apps requiring maximum AOT performance
- Trade-off: Manual maintenance of serialization context

### Strategy 3: Simple Types Only
- Design actor interfaces to use only simple types
- Best for: Performance-critical scenarios, embedded systems
- Trade-off: May require additional mapping layers

## Best Practices

1. **Start Simple**: Use the default implementation (current approach)
2. **Test AOT**: Use `dotnet publish -p:PublishAot=true` to check for warnings
3. **Optimize if Needed**: Only create custom contexts if you see warnings or performance issues
4. **Keep Types Simple**: Prefer DTOs with simple property types over complex nested structures

## Example: AOT-Friendly Actor Design

```csharp
// ✅ Good: Simple, AOT-friendly
public interface IUserActor : IQuarkActor
{
    Task<UserInfo> GetUserAsync();
    Task UpdateNameAsync(string name);
}

public class UserInfo
{
    public string Id { get; set; }
    public string Name { get; set; }
    public DateTime CreatedAt { get; set; }
}

// ⚠️ Acceptable: Works but may use reflection
public interface IEventActor : IQuarkActor
{
    Task ProcessEventAsync(Dictionary<string, object> eventData);
}

// ❌ Avoid: Polymorphic types require reflection
public interface IShapeActor : IQuarkActor
{
    Task<IShape> GetShapeAsync(); // IShape with multiple implementations
}
```

## Future Improvements

We are exploring these options for future releases:

1. **Configuration API**: Allow specifying custom JsonSerializerContext
2. **Code Generation**: Generate complete serialization code without relying on System.Text.Json's generator
3. **Analyzer**: Detect and warn about types that may cause AOT issues

## Summary

Quark's current System.Text.Json implementation provides:
- ✅ Excellent compatibility with Native AOT for common scenarios
- ✅ Zero additional configuration required
- ✅ Better than the previous protobuf-net implementation (which used reflection extensively)
- ⚠️ Potential for reflection in complex type scenarios (same as any .NET app using JSON)

For most applications, the current approach is sufficient. For applications with strict AOT requirements, use simple types and test with `PublishAot=true`.

## Related Documentation

- [.NET AOT Deployment](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/)
- [System.Text.Json Source Generation](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/source-generation)
- [Quark Actor Model](ACTOR_MODEL.md)
